# bash 学习笔记

**注释：**

- 全文参考 bash 手册，阅读原文：`man bash`，或者[在线 man page](https://man7.org/linux/man-pages/man1/bash.1.html)
- 笔记只摘录个人感兴趣的内容，个人的理解放到注释下面
- 注释文字中，控制台输入 `ls -l`，`ls -l` 是命令字符串，默认后面输入回车键，下文不再赘述
- 如果想查看中文手册，ubuntu 安装方式：`sudo apt install manpages-zh`
- 感谢中文 man 翻译计划，github 仓库地址：`https://github.com/man-pages-zh/manpages-zh`

## 名称

bash - GNU Bourne-Again SHell (GNU 命令解释程序 “Bourne 二世”)

## 描述

Bash 是一个与 sh 兼容的**命令解释程序**，可以执行从**标准输入**或者**文件**中读取的命令。

**注释：**

- 直接在控制台输入 `sh`，进入交互式的 sh
- 输入 `ls` 和 `exit` 两个命令，跟 bash 下的体验差不多
- sh 是 Bourne Shell，Bourne 一代；而 bash 是 Bourne 二代

## 概述

` bash [options] [command_string | file]`

**注释：**

- bash 完整命令行格式为：`bash [长选项] [短选项] [命令字符串 | 脚本文件名]`
- 长选项要放到短选项之前，参考：`bash --help`，以及下面的[选项](#选项)章节

## 选项

### 长选项

`--help`      在标准输出显示用法信息并成功退出

`--version`   在标准输出显示此 bash 的版本信息并成功退出

**注释：**

- 控制台输入 `bash --help`，查看 bash 的帮助信息
- 控制台输入 `bash --version`，查看 bash 的版本信息
- bash 手册也是有版本的，bash 手册的版本跟 bash 版本保持一致
- bash 手册的版本在 `man bash` 最后一行
- bash 中文手册的版本是 `2.05b` 非常低，现在 bash 的版本是 `5.1`
- 基本常识，软件的版本号越大，功能越多，而且软件基本上向下兼容
- 因此，低版本的 bash 功能是高版本 bash 的子集

### 短选项

`-c cmd_string`   如果有 -c 选项，那么命令将从 cmd_string 中读取。如果 cmd_string 后面有参数，它们将用于给位置参数（位置参数以 $0 起始）赋值。

`-i`              如果有 -i 选项，shell 将交互地执行。

**注释：**

- 不用 `-i` 选项，控制台输入 `bash`，默认就会进入交互式的 Shell
- 所以 `-i` 选项的用处不大，关键是要知道 Shell 分为**交互模式**和**非交互模式**
- `-c` 选项，`c` 代表 command，`-c string` 是非交互式运行 string 中的命令
- 控制台输入 `bash -c "ls -l"`，查看当前目录下的内容，当然不如 `ls -l` 来的直接
- 控制台输入 `bash -c help` 获取帮助信息，`help` 是 bash 内置命令，zsh 不支持 `help` 内置命令
- node 和 python 作为脚本解释器，跟 bash 命令解释器的用法类似，下面是两个非交互模式
- `node -e "console.log('Hello, nodejs world!')"`，类似 `bash -c "echo 'Hello, bash world!'`
- `python3 -c "print('Hello, python world!')"`，类似 `bash -c "echo 'Hello, bash world!'`
- 交互模式，就是对话模式，输入命令，输出命令执行的结果，输入和输出是一问一答，就是交互模式
- 控制台输入 `bash`，进入交互模式后，输入 `help` 查看帮助信息，`exit` 退出交互模式
- 控制台输入 `bash`，输入 `echo "Hello, bash world!"`，输入 `pwd`，输入 `ls`，输入 `exit`
- 非交互模式，就是批处理模式或脚本模式，输入脚本文件，输出脚本文件执行的结果
- 这个手册即有交互式 Shell 的用法，也有非交互式 Shell 的用法，也就是 Shell 编程
- 编写一个简单的脚本文件 `hello.sh` 内容如下：
```bash
echo 'Hello, bash world!'
echo 'I am wangding.'
```
- 控制台输入 `bash hello.sh`，以非交互模式运行 `hello.sh` 脚本文件，bash 是脚本解释器
- 如果有 nodejs 或 python 脚本编程的经验，bash 的两种运行方式很容易理解
- `node hello.js`，以非交互模式运行 `hello.js` 脚本文件，可以做 `bash hello.sh` 类似的事情
- `python3 hello.py`，以非交互模式运行 `hello.py` 脚本文件，可以做 `bash hello.sh` 类似的事情
- `node` 和 `python3` 进入交互模式，跟 `bash` 交互模式类似，用 `exit` 退出交互模式
- bash 是鼻祖，nodejs 和 python 参考和借鉴 bash 是肯定的

`-r`          如果有 -r 选项，shell 成为受限的（参见下面的[受限的 shell](#受限的-shell) 章节）。

`-s`          如果有 -s 选项，或者如果选项处理完以后，没有参数剩余，那么命令将从标准输入读取。这个选项允许在启动一个交互 shell 时可以设置位置参数。

`[-+]O [shopt_option]` shopt_option 是一个 shopt 内置命令可接受的选项（参见下面的[内置命令](#内置命令)章节）。如果有 shopt_option，-O 将设置那个选项的取值；+O 取消它。如果没有给出 shopt_option，shopt 将在标准输出上打印设为允许的选项的名称和值。

`--`          -- 标志选项的结束，禁止其余的选项处理。任何 -- 之后的参数将作为文件名和参数对待。参数 - 与此等价。

**注释：**

- `-r` 用处不大，知道有受限 Shell，了解一下受限 Shell 有哪些功能被阉割了就行
- `-s` 用处不大，关于参数位置，`-c string` 选项中也提到了，执行下面的操作就明白了
```bash
bash -s 1 2
echo $0
echo $1
echo $2
```
- 脚本文件执行时，也可以有命令行参数，编写包含上面三个 echo 命令的脚本文件 `parameters.sh`
- 控制台输入 `bash parameters.sh 1 2`，查看输出结果，注意 $0 代表的是脚本文件本身
- `[-+]O [shopt_option]` 这个选项可以设置或查看 bash 参数，不同的参数控制 bash 的不同行为
- 控制台输入 `bash -O`，列出 bash 所有参数，并进入 bash 交互模式，on 为参数开启状态，off 为参数关闭状态
- 以 interactive_comments 参数为例，`interactive_comments on`，这个参数默认为开启状态，允许命令行注释
- 输入 `#ls`，控制台没有报错，`#` 后面的内容视为注释，bash 直接忽略，`exit` 退出 bash 交互模式
- 关闭 interactive_comments 参数，控制台执行 `bash +O interactive_comments`，进入 bash 交互模式
- 控制台输入 `shopt` 查看 bash 所有参数状态，看到 `interactive_comments off`
- 控制台输入 `#ls`，提示 `找不到命令 “#ls”`，说明此时 bash 不支持控制台的 `#` 注释行为

## 参数（arguments）

如果选项处理之后仍有参数剩余，并且没有指定 -c 或 -s 选项，第一个参数将假定为一个包含 shell 命令的文件的名字。

如果 bash  是以这种方式启动的，$0 将设置为这个文件的名字，位置参数将设置为剩余的其他参数。

Bash 从这个文件中读取并执行命令，然后退出。Bash 的退出状态是脚本中执行的最后一个命令的退出状态。如果没有执行命令，退出状态是 0。

尝试的步骤是先试图打开在当前目录中的这个文件，接下来，如果没有找到，shell 将搜索脚本的 PATH 环境变量中的路径。

**注释：**

- 编写 parameters.sh 内容如下：
```bash
echo $0
echo $1
echo $2
```
- 控制台输入 `bash parameters.sh 1 2`，观察输出内容，$0 表示 parameters.sh，$1 是 1，$2 是 2

## 启动

当 bash 是作为交互的登录 shell 启动的，或者是一个非交互的 shell 但是指定了 `--login` 选项，它首先读取并执行 `/etc/profile` 中的命令，只要那个文件存在。读取那个文件之后，它以如下的顺序查找 `~/.bash_profile`，`~/.bash_login`，和 `~/.profile`，从存在并且可读的第一个文件中读取并执行其中的命令。`--noprofile` 选项可以用来在 shell 启动时阻止它这样做。

当一个登录 shell 退出时， bash 读取并执行文件 `~/.bash_logout` 中的命令，只要它存在。

当一个交互的 shell 但不是登录 shell 启动时，bash 从文件 `~/.bashrc` 中读取并执行命令，只要它存在。可以用 `--norc` 选项来阻止它这
样做。`--rcfile file` 选项将强制 bash 读取并执行文件 file 中的命令，而不是 `~/.bashrc` 中的。

**注释：**

- `cat /etc/profile`，查看 `/et/profile` 文件内容，暂时看不懂没关系，把这个文档都学完了，自然就懂了
- `cat ~/.profile`，查看 `~/.profile` 文件内容
- `cat ~/.bash_logout`，查看 `~/.bash_logout` 文件内容
- 打造酷炫的登录欢迎信息，`sudo apt install screenfetch`
- 修改 .bashrc 文件，在其中添加 `screenfetch 2>/dev/null`
- 控制台输入 `bash`，进入 bash 交互模式，看到 screenfetch 输出，有 Linux 发行版的 Logo 及系统信息
- 另一种可选方案是使用 fortune，登录后显示名言和古诗词

## 定义

下列定义在文档余下部分中通用。

`blank` 空白

一个空格或是 tab

`word` 词

一个字符序列，shell 将它们视为一个结构单元，也称为一个 token 片段。

`name` 名称

一个只由字母，数字和下划线构成的词，并且以字符或下划线起始，也称为一个标识符。

`metacharacter` 元字符

一个字符，如果不是引用的话，将成为词的分隔符。它是这些字符之一：`|  & ; ( ) < > space tab newline`

`control operator` 控制操作符

一个标识，拥有控制功能。它是这些符号之一：`|| & && ; ;; ;& ;;& ( ) | |& <newline>`

**注释：**

- 这些术语是下面描述 Shell 编程语法时会用到的，如果对 Shell 编程不感兴趣这些可以忽略
- 如果有 C 语言或者其他高级语言的编程经验，部分元字符和控制操作符的作用跟编程语言是类似的
- `name` 名称相当于编程语言中的变量名和函数名，即标识符
- `metacharacter` 如果不是引用，将成为词的分隔符，下面逐一介绍每个符号
- `|` 是管道操作符，它可以把多个简单命令连接组合成复杂功能的管道命令
- 管道操作符是个非常强大的功能，手册后面还会详细介绍
- `&` 用途很多，放到命令后面时，命令被放到后台运行，也可以用在重定向，后面会详细介绍
- `;` 类似 C 语言中语句的分隔符，也是 for 循环中，循环变量初始化、递增和退出条件的分隔符
- `()` 类似 C 语言中的 if、switch、 while 等条件表达式的用法
- `< >` 用于重定向，或在条件表达式中表示小于和大于
- `control operator` 控制操作符，拥有控制功能，下面逐一介绍每个符号
- `||` 类似 C 语言中逻辑或运算
- `&&` 类似 C 语言中的逻辑与运算
- 其他控制操作符在元字符中提到了，用法类似，就不再赘述了

## 保留字

保留字是对 shell 有特殊意义的词。下列词被识别为保留的，如果不是引用，并且不是一个简单命令的起始词（参见下面的[Shell 语法](#Shell-语法)），也不是 case 或者 for 命令的第三个词：

`! case coproc do done elif else esac fi for function if in select then until while { } time [[ ]]`

**注释：**

- 学过编程的人都知道，保留字就是编程语言中的关键字，保留字不允许用作变量名或函数名
- 大部分保留字跟 C 语言中的关键字用法相同

## shell 语法

**注释：**

- 这个章节的内容尤其是复合命令，涉及 Shell 非交互模式，即 Shell 编程的内容
- shell 语法中的简单命令、管道命令、列表命令和复合命令
- 类似编程语言中的变量和运算符、表达式、语句和语句块之间的层次关系
- 多个简单命令通过管道操作符可以连接成管道命令
- 多个简单命令或者多个管道命令又组成列表命令
- 多个列表命令又组成复合命令
- 从编程语言的语法角度来理解这些概念，会简单和容易很多
- 站在编程语言的语法角度，shell 语法不是什么新鲜玩意

### 简单命令

简单命令是（可选的）一系列变量赋值，紧接着是空格分隔的词和重定向，然后以一个控制操作符结束。

第一个词指明了要执行的命令，它被作为第 0 个参数。其余词被作为这个命令的参数。

简单命令的返回值是它的退出状态，或是 128+n，如果命令被信号 n 结束的话。

**注释：**

- 说人话，简单命令就是一个命令，格式为：`command [options] [arguments]`
- 命令字符串是第 0 个参数，即 $0，后续的选项和参数用空格分割
- 关于退出码，正常退出是 0。异常退出，在控制台依次输入下面的命令：
```bash
z note
gitbook serve --port 8080
ctrl + c
echo $?
```
- 退出码是 130，`ctrl + c` 的信号是 `SIGINT` 信号的值 n 是 2，所以退出码是 `128+2 = 130`
- 查看信号的资料，输入命令：`man 7 signal`

### 管道命令

管道是一个或多个命令的序列，用字符 | 分隔。管道的格式是这样:

`[time [-p]] [ ! ] command [ | command2 ... ]`

命令 command 的标准输出通过管道连接到命令 command2 的标准输入。连接是在命令指定的任何重定向之前进行的。

如果保留字 ! 作为管道前缀，管道的退出状态将是最后一个命令的退出状态的逻辑非值。否则，管道的退出状态就是最后一个命令的。

如果保留字 time 作为管道前缀，管道中止后将给出执行管道耗费的用户和系统时间。

**注释：**

- time 用来做基准测试，返回命令运行的时长，单位是秒
- zsh 的 time 输出结果，格式有些混乱
- 通过 time 可以很方便的做基准测试，例如：比较 nodejs 和 python 解释器的速度
- 在控制台输入 `bash`，进入交互模式后，在控制台输入下面两个命令
```bash
time node -e "console.log('helo')"
time python3 -c "print('hello')"
```
- 基准测试结果，应该是 python 解释器的速度更快
- 注意 time 不是内置命令，应该是 Bash 保留关键字，控制台输入：`which time` 验证一下
- 类似的内置命令是 times，控制台输入：`which times` 验证一下
- `/usr/bin/time` 同样是做基准测试的工具，功能要更强大一些，控制台输入下面两个命令
```bash
/usr/bin/time -v node -e "console.log('hello')"
/usr/bin/time -v python3 -c "print('hello')"
```
- `!` 是逻辑非值，跟 C 语言中的取反逻辑运算相同
- 在控制台输入 `ls` 和 `echo $?`
- 在控制台输入 `! ls` 和 `echo $?`
- unix 的哲学是小而美，每个命令的功能单一
- 通过管道操作把多个简单命令连接起来，完成一个复杂功能
- 例如：下面的管道命令，用来计算某个目录下 JavaScript 文件的代码行数
- `find . -name '*.js' ! -path "./**/node_modules/*" ! -path "./node_modules/*" | xargs cat | grep -v ^$ | wc -l`
- 现代化图形界面的 IDE，很少提供类似的代码行数统计功能，可见 bash 的强大，以及顽强的生命力
- 例如：完成文本行的排序和去重，控制台输入：`cat data.txt | sort | uniq`

### list 命令

list 命令是一个或多个管道。用操作符 ;，&，&&，或 ⎪⎪ 分隔的序列，并且可以选择用 ;，&，或新行符结束。

这些 list 操作符中，&& 和 ⎪⎪ 优先级相同，其次是 ; 和 &，它们的优先级是相同的。

list 中可以有一个或多个新行符来分隔命令，而不是使用分号分隔。

如果一个命令是由控制操作符 & 结束的，shell 将在后台的子 shell 中执行这个命令。shell 不会等待命令执行结束，返回状态总是 0。以分号 ; 分隔的命令会被顺序执行；shell 会等待每个命令依次结束。返回状态是最后执行的命令的返回状态。

控制操作符 && 和 ⎪⎪ 分别代表 AND 和 OR 序列。

一个 AND 序列的形式是：`command1 && command2`，command2 只有在 command1 返回 0 时才被执行。

一个 OR 序列的形式是：`command1 ⎪⎪ command2`，command2 只有在 command1 返回非 0 时才被执行。

AND 和 OR 序列的返回状态是 list 中最后执行的命令的返回状态。

**注释：**

- 三种逻辑运算：取反 !，与 &&，或 ||，还有分号的语句结尾，Shell 语法跟 C 语法如出一辙
- 结合下面的复合命令描述，list 命令其实就是命令组成的语句块
- 控制台执行两个列表命令：`pwd; echo '-------'; ls;` 和 `pwd; ls | sort;`
- 根据手册描述，上面两个 list 命令，最好用新行来隔开两个命令
- 这两个 list 命令，之所以没有这样做，是因为用新行，就成交互模式了
- 但是放到脚本里面是没有问题，例如：脚本文件 `list.sh` 内容如下：
```bash
pwd
echo '--------------'
ls -l
```
- 控制台输入：`bash list.sh`
- & 符号放到命令末尾，这个命令将在后台运行，注意是否为挂起状态，挂起的进程不会执行
- `vim &` vim 在后台运行，是挂起状态，`fg` 可以把 vim 调到前台
- 关于 && 和 || 两种列表命令的执行方式，执行以下的操作来体会一下
- 控制台输入：`pwd && ls` 和 `! pwd && ls` 观察两者的区别
- 控制台输入：`pwd || ls` 和 `! pwd || ls` 观察两者的区别

### 复合命令

复合命令是如下情况之一：

`(list)`

list 命令将在一个子 shell 中执行。变量赋值和影响 shell 环境变量的内建命令在命令结束后不会再起作用。返回值是序列的返回值。

`{ list; }`

list 命令将在当前 shell 环境中执行。序列必须以一个新行符或分号结束。这种做法也称为命令组。返回值是序列的返回值。注意与元字符 ( 和 ) 不同， { 和 } 是保留字，必须出现在能够识别保留字的场合。由于它们不会产生断词，它们和序列之间必须用空格分开。

`((expression))`

表达式 expression 将被求值。求值规则在下面的[算术求值](#算术求值)章节中描述。如果表达式的值非零，返回值就是 0；否则返回值是 1。这种做法和 let "expression" 等价。

`[[ expression ]]`

返回 0 或 1，取决于条件表达式 expression 求值的情况。表达式是由下面[条件表达式](#条件表达式)章节中描述的原语组成。[[ 和 ]] 中的词不会进行词的拆分和路径的扩展处理；而 tilde 扩展，参数和变量扩展，算术扩展，命令替换，函数替换和引用的去除则都将进行。

当使用 == 和 != 操作符时，操作符右边的字符串被认为是一个模式，根据下面[模式匹配](#模式匹配)章节中的规则进行匹配。如果匹配则返回值是 0，否则返回 1。模式的任何部分可以被引用，强制使它作为一个字符串而被匹配。

表达式可以用下列操作符结合起来。根据优先级的降序列出：

- `( expression )` 返回表达式 expression 的值。括号可以用来提升操作符的优先级
- `! expression` 返回真，前提是表达式 expression 返回假
- `expression1 && expression` 返回真，前提是表达式 expression1 和 expression2 都返回真。
- `expression1 || expression2` 返回真，前提是表达式 expression1 或者 expression2 二者之一返回真。

&& 和 || 操作符不会对表达式 expression2 求值，前提是 expression1 可以决定整个条件表达式的返回值。

`for name [ in word ] ; do list ; done`

in 之后的一系列词会被扩展，产生一个项目列表。变量 name 被依次赋以这个列表中的每个元素，序列 list 每次都被执行。如果 in  word 被忽略，那么 for 命令遍历已设置的位置参数（参见下面的[参数](#参数（parameters）)章节），为每一个执行一次序列 list。返回值是最后一个命令的返回值。如果 in 之后的词扩展的结果是空列表，就不会执行任何命令，返回值是 0。

`for (( expr1 ; expr2 ; expr3 )) ; do list ; done`

首先，算术表达式 expr1 被根据下面[算术求值](#算术求值)中的规则进行求值。然后算术表达式  expr2  被循环求值，直到它等于 0。每次 expr2 结果非零时，序列 list 都被执行，算术表达式 expr3 被求值。如果任何表达式被忽略，将被视为执行结果是 1。返回值是序列 list 中被执行的最后一个命令的返回值；或者是 false，如果任何表达式非法的话。

`select name [ in word ] ; do list ; done`

in 之后的一系列词会被扩展，产生一个项目列表。这个扩展后的词集合被输出到标准错误上，每个前面加上一个数字。如果 in word 被忽略，将输出位置参数（参见下面的[参数](#参数（parameters）)章节）。PS3 提示符将被显示出来，等待从标准输入得到一行输入。如果输入是一个数字且显示中有对应的词，那么变量 name 的值将设置为这个词。如果输入一个空行，那么词和提示符将再次显示出来。如果读入了一个 EOF，命令就结束。任何其他值将设置变量 name 为空。读入的行保存为变量 REPLY，序列 list 在每次选择之后都会执行，直到执行了一个 break 命令。select 的退出状态是序列 list 中执行的最后一个命令的退出状态，如果没有执行命令就是 0。

`case word in [ [(] pattern [ | pattern ] ... ) list ;; ] ... esac`

case 命令首先扩展 word，然后依次试着用每个 pattern 来匹配它，使用与路径扩展相同的匹配规则（参见下面的[路径扩展](#路径扩展)章节）。如果找到一个匹配，相应的序列将被执行。找到一个匹配之后，不会再尝试其后的匹配。如果没有模式可以匹配，返回值是 0。否则，返回序列中最后执行的命令的返回值。

`if list; then list; [ elif list; then list; ] ... [ else list; ] fi`

序列 if list 被执行。如果退出状态是 0，then list 将被执行。否则，每个 elif 将被一次执行，如果退出状态是 0，相应的 then list 将被执行，命令结束。否则，else list 将被执行，如果存在的话。退出状态是最后执行的命令的退出状态，或者是 0，如果所有条件都不满足。

`while list; do list; done`
`until list; do list; done`

while 命令不断地执行序列 do list，直到序列中最后一个命令返回 0。until 命令和 while 命令等价，除了对条件的测试恰好相反；序列 do list 执行直到序列中最后一个命令返回非零状态值。while 和 until 命令的退出状态是序列 do list 中最后一个命令的退出状态，或者是 0，如果没有执行任何命令。

`[ function ] name () { list; }`

这样可以定义一个名为 name 的函数。函数体 body 是包含在 { 和 } 之间的命令序列 list。在指定将 name 作为一个命令运行的场合，这个序列将被执行。函数的退出状态是函数体最后执行的命令的退出状态。

**注释：**

- 如果有编程基础，复合命令没什么难度，主要就是分支和循环两种流程控制
- 在控制台逐行输入下面的命令，体会一下
```bash
age=25; if(($age>20)); then echo 'You are a man.'; else echo 'You are a boy.'; fi
for name in /*; do echo $name; done
for((num=0; num<5; num++)); do echo wangding; done
select name in /*; do echo $name; done
```

- 剩余大部分的示例，以脚本文件的方式运行，`bash file.sh`

- `for.sh`

  ```bash
  for num in {1..5} ;
  do
  echo "$num  wangding"
  done

  echo '------------'

  for num in {5..1} ;
  do
  echo "$num  wangding"
  done
  ```

- `for-in-step.sh`

  ```bash
  for num in {1..9..2} ;
  do
  echo "$num  wangding"
  done
  ```

- `for-string.sh`

  ```bash
  str="My name is wangding and am 20 years old.";

  for word in $str;
  do
  echo $word
  done
  ```

- `for-break.sh`

  ```bash
  num=1
  for((; ;));
  do
  echo "$num wangding"
  ((num++))
  if(( $num > 5 )); then
    break;
  fi
  done
  ```

- `while.sh`

  ```bash
  num=0
  while [ $num -lt 10 ];
  do
  echo 'wangding'
  ((num++))
  done
  ```

- `while-c-style.sh`

  ```bash
  num=0
  while (($num < 10));
  do
  echo 'wangding'
  ((num++))
  done
  ```

- `while-break.sh`

  ```bash
  num=1
  while :
  do
  echo "$num: wangding"
  ((num++))
  if [ $num -gt 5 ];
  then
    break
  fi
  done
  ```

- `while-continue.sh`

  ```bash
  num=0
  while [ $num -lt 10 ];
  do
  ((num++))
  if [ $((num%2)) -eq 0 ];
  then
    continue
  fi
  echo "$num: wangding"
  done
  ```

- `while-case-opt.sh`

  ```bash
  echo 'bash while-case-opt.sh -n wangding -a 20'

  while getopts n:a: OPT
  do
  case "${OPT}"
  in
    n) name=${OPTARG};;
    a) age=${OPTARG};;
    *) echo "Invalid option"
  exit 1;;
  esac
  done

  printf "My name is $name and am $age years old.\n"
  ```

- `while-operate-file.sh`

  ```bash
  while read a b c
  do
  echo $b - $a
  done < languages.txt
  while-read-file.sh
  num=1
  while read -r line;
  do
  echo "$num:  $line"
  ((num++))
  done < /etc/passwd
  ```

- `languages.txt`

  ```
  Language    type      released
  Python      general   1991
  Javascript  web       1995
  Java        mobiLe    1995
  Rust        embebded  2010
  Go          backend   2007
  ```

- `case.sh`

  ```bash
  scores=(95 81 88 56 34 71)

  for s in ${scores[@]};
  do
  case $(($s/10)) in
    9) echo "$s 优";;
    8) echo "$s 良";;
    7) echo "$s 中";;
    6) echo "$s 及格";;
    *) echo "$s 不及格";;
  esac
  done
  ```

- `function.sh`

  ```bash
  factorial() {
  if [ $# -eq 0 ]; then
    return 0
  fi

  local fac=1
  for((num=1; num<=$1; num++));
  do
    ((fac*=$num))
  done
  return $fac
  }

  n=5
  factorial $n
  echo "$n! = $?"
  ```

## 注释

`#` 开头行都被忽略，通常用在非交互模式。交互模式下，使用内建命令 shopt 启用了 interactive_comments 选项，`#` 也起注释作用。

**注释：**

- 经常用在非交互模式，在 Shell 编程中，用来对脚本程序编写代码注释，帮助他人理解脚本程序
- 交互模式下 interactive_comments 选项默认是启用的，所以交互模式也可以使用注释
- 不通读 bash 手册的人，很少有人知道这个控制台小技巧，zsh 的交互模式也是启用的
- 这个 bash 黑科技的关键是注释内容会放到历史命令里
- 在控制台执行下面的操作，体会一下
- `#ls`, `history` 会看到 `#ls` 命令, `ctrl+r ls` 会调出历史命令
- 下面是这个技巧的使用场景
- 假设我们要执行某个命令 c1，命令敲了一半，发现需要先执行另一个命令 c2，c1 回头再执行
- 如果不知道这个技巧，我们会敲快捷键 ctrl + u，把控制台当前的 c1 命令删除，再输入 c2 命令
- c2 完成后，再把 c1 命令重新敲一遍，完成最终的操作
- 知道这个技巧后，不需要 ctrl + u 删除 c1 命令，而是在 c1 命令行首添加 `#` 字符，敲回车
- 这个时候注释的 c1 命令会到放到命令历史中，直接敲 c2 命令，c2 执行完后
- 从命令历史中调出来注释掉的 c1 命令，去掉最前面的注释符号，来运行 c1 命令
- 因为是从命令历史中调出的 c1 命令，避免了从头输入 c1 命令，提高了工作效率

## 引用

引用用来去掉特定字符或词的特殊意义。引用可以用来禁止对特殊字符的处理，阻止保留字被识别，还用来阻止参数的扩展。

上面在[定义](#定义)中列出的每个元字符对于 shell 都有特殊意义。如果要表达它的本义，必须引用它。

在使用命令历史扩展功能时（见下面的[历史扩展](#历史扩展)），历史扩展字符，通常是 `!`，必须被引用，才会阻止历史扩展。

有三种引用机制：

- 转义字符
- 单引号
- 双引号

一个未被引用的反斜杠（\）是转义字符。它保留其后一字符的字面意义，除非那是一个新行符。如果 `\` 和新行符成对出现，并且反斜杠自身没有被引用，那么 `\<newline>` 被视为续行标志（意思是，它从输入流中删除，并被忽略了）。

将字符放在单引号之中，将保留引用中所有字符的字面意义。单引号不能包含在单引号引用之中，即使前面加上了反斜杠。

将字符放在双引号中，同样保留所有字符的字面意义，例外的情况是 `$`, \`, 和 `\`。 字符 `$` 和 \` 在双引号中仍然具有特殊意义。反斜杠只有后面是下列字符时才有特殊意义： `$`, \`, `"`, `\`, 或 `<newline>`。双引号可以包含在双引号引用中，但要在前面加上一个反斜杠。

特殊的参数 `*` 和 `@` 在双引号中有特殊意义（参见下面的[参数](#参数（parameters）)章节）。

形式为 `$'string'` 的词会被特殊处理。它被扩展为 string，其中的反斜杠转义字符被替换为 ANSI C 标准中规定的字符。反斜杠转义序列，如果存在的话，将做如下转换：

- `\a`     alert (bell) 响铃
- `\b`     backspace 回退
- `\e`     an escape character 字符 Esc
- `\f`     form feed 进纸
- `\n`     new line 新行符
- `\r`     carriage return 回车
- `\t`     horizontal tab 水平跳格
- `\v`     vertical tab 竖直跳格
- `\\`     backslash 反斜杠
- `\'`     single quote 单引号
- `\nnn`   一个 ASCII 字符，它的值是八进制值 nnn（一到三个八进制数）
- `\xHH`   一个 ASCII 字符，它的值是十六进制值 HH（一到两个十六进制数）
- `\uHHH`  一个 Unicode 字符，它的值是十六进制值 HHH（一到三个十六进制数）
- `\UHHHHHHHH` 一个 Unicode 字符，它的值是八进制值 HHHHHHHH（一到八个八进制数）
- `\cx`    一个 ctrl-x 字符

扩展结果是单引号引用的，就好像 `$` 符号不存在一样。

双引号引用字符串前面加上一个 `$` 符号将使得这个字符串被根据当前语言环境来翻译。如果当前语言环境是 C 或者 POSIX，这个符号将被忽略。 如果这个字符串被翻译并替换了，那么替换结果是双引号引用的。

**注释：**

- 三种引用机制：转义字符（`\`），单引号（`'`）和双引号（`"`）
- 转义字符的作用，输出特殊字符，格式：`$'string'`，支持的转换，见上面的列表
- 在控制台逐行输入下列命令，查看转义效果
```bash
echo $'hello\nworld'
echo $'hello\tworld'
echo $'hello\aworld'
echo $'hello\bworld'
echo $'\150\145\154\154\157\40\167\157\162\154\144'
echo $'\x68\x65\x6c\x6c\x6f\x20\x77\x6f\x72\x6c\x64'
echo $'\u68\u65\u6c\u6c\u6f\u20\u738b\u9876'
```
- `cat parameters.sh | tr $'\n' ';'`，`tr` 命令将 `parameters.sh` 脚本文件中的换行符替换成了 `;`
- 转义字符有一特殊用途，就是命令行续行
- 一行命令太长写不下，可以用转义字符加换行符，另起一行，bash 会视为一行
- 在控制台分别输入两个 echo 命令，体验一下
```bash
echo Hello, bash world!
echo Hel\
lo, ba\
sh world!
```
- 除了转义字符，单引号和双引号才是真正的引用
- 引用的作用，是消除元字符和控制符的特殊含义，得到该字符的本体
- 单引号比双引号消除特殊含义的效果更强
- 也就是说有些字符在双引号中消除不了特殊含义
- 控制台逐行输入下面的命令，比较单引号和双引号的效果
```bash
echo '$(pwd)'
echo "$(pwd)"
echo '`pwd`'
echo "`pwd`"
```
- `$(pwd)` 和 \`pwd\` 的作用等价，都是命令替换，即，得到 `pwd` 命令的输出
- 单引号消除了命令替换，双引号没有消除命令替换
- 单引号消除了 `$`，`()` 和 \` 字符的特殊含义，双引号没有消除

## 参数（parameters）

### 位置参数

### 特殊参数

### Shell 内置变量

### 数组

Bash 提供了一维数组变量。任何变量都可以作为一个数组；内建命令 declare 可以显式地定义数组。数组的大小没有上限，也没有限制在连续对成员引用和 赋值时有什么要求。数组以整数为下标，从 0 开始。

如果变量赋值时使用语法 name[subscript]=value， 那么就会自动创建数组。 subscript 被当作一个算术表达式，结果必须是大于等于 0 的值。要显式地定义一个数组，使用  declare -a name (参见下面的 shell 内建命令(SHELL BUILTIN COMMANDS) 章节)。也可以用 declare -a name[subscript] 这时  subscript 被忽略。数组变量的属性可以用内建命令 declare 和 readonly 来指定。每个属性对于所有数组元素都有效。

数组赋值可以使用复合赋值的方式，形式是  name=(value1 ... valuen)，这里每个 value 的形式都是 [subscript]=string。string 必须出现。如果出现了可选的括号和下标，将为这个下标赋值，否则 被赋值的元素的下标是语句中上一次赋值的下标加一。下标从 0 开始。 这个语法也被内建命令 declare 所接受。单独的数组元素可以用上面介绍的语法 name[subscript]=value 来赋值。

数组的任何元素都可以用 ${name[subscript]} 来引用。 花括号是必须的，以避免和路径扩展冲突。如果 subscript 是 @ 或是 \*，它扩展为 name 的所有成员。这两种下标只有在双引号中才不同。在双引号中，${name[\*]}  扩展为一个词，由所有数组成员的值组成，用特殊变量 IFS 的第一个字符分隔；${name[@]} 将 name 的每个成员扩展为一个词。 如果数组没有成员，${name[@]} 扩展为空串。这种不同类似于特殊参数 * 和 @ 的扩展 (参见上面的 Special Parameters 段落)。${#name[subscript]} 扩展为 ${name[subscript]} 的长度。如果 subscript 是 * 或者是 @，扩展结果是数组中元素的个数。引用没有下标数组变量等价于 引用元素 0。

内建命令  unset  用于销毁数组。unset  name[subscript]  将销毁下标是 subscript 的元素。 unset name, 这里 name 是一个数组，或者 unset name[subscript], 这里 subscript 是 * 或者是 @，将销毁整个数组。

内建命令 declare, local, 和 readonly 都能接受 -a 选项，从而指定一个数组。内建命令 read 可以接受 -a 选项，从标准输入读入一列词来为数组赋值。内建命令 set 和 declare 使用一种可以重用为输入的格式来显示数组元素。

## 扩展

### 花括号扩展

### Tilde 扩展

如果一个词以没有引用的波浪线字符 (`~') 开始，所有 在第一个没有引用的斜线 (`/') 之前的字符 (或者是这个词的所有字符，  如果没有没引用的斜线的话) 都被认为是 tilde-prefix(波浪线前缀)。 如果 tilde-prefix 中没有被引用的字符，那么波浪线之后的字符串 被认为是login name(登录名)。如果登录名是空字符串，波浪线将 被替换为 shell 参数 HOME 的值。如果没有定义 HOME， 将替换为执行此 shell 的用户的个人目录。否则，tilde-prefix 被替换为 与指定登录名相联系的个人目录。

如果  tilde-prefix 是 `~+'，将使用 shell 变量 PWD 的值来替换。如果 tilde-prefix 是 `~-'，并且设置了 shell 变量 OLDPWD, 将使用这个变量值来替换。如果在 tilde-prefix 中，波浪线之后的字符串 由一个数字 N 组成，前缀可选的 `+' 或者 `-'，那么 tilde-prefix 将被替换为目录栈中相应的元素，就是将  tilde-prefix 作为参数执行内建命令 dirs 显示的结果。如果 tilde-prefix 中波浪线之后的字符是一个数字，没有前缀， 那么就假定有一个 `+'。

如果登录名不合法，或者波浪线扩展失败，这个词将不会变化。

在变量赋值中，对于 : 或 = 之后的字符串会立即检查未引用的 tilde-prefix。  这种情况下，仍然会进行波浪线扩展。因此，可以使用带波浪线的文件名来为 PATH, MAILPATH, 和 CDPATH 赋值，shell 将赋予扩展之后的值。

### 参数扩展

字符  `$' 引入了参数扩展，命令替换和算术扩展。要扩展的参数名或符号 可能包含在花括号中，花括号可选的，但是可以使得要扩展的变量
不会与紧随其后 的字符合并，成为新的名称。

使用花括号的时候，匹配的右括号是第一个  `}'，并且它没有被反斜杠引用  或包含在一个引用的字符串中，也没有包含在一个嵌入的算术扩
展，命令替换 或是参数扩展中。

${parameter}
        被替换为  parameter 的值。如果 parameter 是一个位置参数，并且数字多于一位时；或者当紧随 parameter 之后有不属于名称一部
        分的字符时，都必须加上花括号。

如果 parameter 的第一个字符是一个感叹号，将引进一层间接变量。 bash 使用以 parameter  的其余部分为名的变量的值作为变量的名称；
接下来新的变量被扩展，它的值用在随后的替换当中，而不是使用 parameter 自身的值。这也称为 indirect expansion(间接扩展).  例外情
况是下面讲到的 ${!prefix*}。

下面的每种情况中，word 都要经过波浪线扩展，参数扩展，命令替换和 算术扩展。如果不进行子字符串扩展，bash 测试一个没有定义或值为
空的 参数；忽略冒号的结果是只测试未定义的参数。

${parameter:-word}
        Use Default Values(使用默认值)。如果 parameter 未定义或值为空，将替换为 word 的扩展。否则，将替换为 parameter 的值。
${parameter:=word}
        Assign  Default  Values(赋默认值)。如果  parameter 未定义或值为空， word 的扩展将赋予 parameter.  parameter 的值将被替
        换。位置参数和特殊参数不能用这种方式赋值。
${parameter:?word}
        Display Error if Null or Unset(显示错误，如果未定义或值为空)。如果  parameter  未定义或值为空，word  (或一条信息，如果
        word 不存在) 的扩展将写入到标准错误；shell 如果不是交互的，则将退出。否则， parameter 的值将被替换。
${parameter:+word}
        Use Alternate Value(使用可选值)。如果 parameter 未定义或值为空，不会进行替换；否则将替换为 word 扩展后的值。
${parameter:offset}
${parameter:offset:length}
        Substring   Expansion(子字符串扩展)。  扩展为parameter  的最多  length  个字符，从  offset  指定的字符开始。如果忽略了
        length，扩展为 parameter 的子字符串， 从 offset 指定的字符串开始。length 和 offset 是算术表达式 (参见下面的 ARITHMETIC
        EVALUATION 算术求值 段落)。 length 必须是一个大于等于 0 的数值。如果 offset 求值结果小于 0， 值将当作从 parameter 的值
        的末尾算起的偏移量。如果 parameter 是 @，结果是 length 个位置参数，从 offset 开始。 如果 parameter 是一个数组名，以  @
        或  *  索引，结果是数组的  length 个成员，从 ${parameter[offset]} 开始。 子字符串的下标是从 0 开始的，除非使用位置参数
        时，下标从 1 开始。

${!prefix*}
        扩展为名称以 prefix 开始的变量名，以特殊变量 IFS 的第一个字符分隔。

${#parameter}
        替换为 parameter 的值的长度 (字符数目)。如果 parameter 是 * 或者是 @, 替换的值是位置参数的个数。如果 parameter  是一个
        数组名，下标是 * 或者是 @, 替换的值是数组中元素的个数。

${parameter#word}
${parameter##word}
        word  被扩展为一个模式，就像路径扩展中一样。如果这个模式匹配 parameter 的值的起始，那么扩展的结果是将 parameter 扩展后
        的值中，最短的匹配 (``#'' 的情况) 或者最长的匹配 (``##''的情况) 删除的结果。如果 parameter 是 @ 或者是 *, 则模式删除操
        作将依次施用于每个位置参数，最后扩展为结果的列表。如果 parameter 是一个数组变量，下标是 @ 或者是 *, 模式删除将依次施用
        于数组中的每个成员，最后扩展为结果的列表。

${parameter%word}
${parameter%%word}
        word 被扩展为一个模式，就像路径扩展中一样。如果这个模式匹配 parameter  扩展后的值的尾部，那么扩展的结果是将  parameter
        扩展后的值中，最短的匹配 (``%'' 的情况) 或者最长的匹配 (``%%''的情况) 删除的结果。如果 parameter 是 @ 或者是 *, 则模式
        删除操作将依次施用于每个位置参数，最后扩展为结果的列表。如果 parameter 是一个数组变量，下标是 @ 或者是 *, 模式删除将依
        次施用于数组中的每个成员，最后扩展为结果的列表。

${parameter/pattern/string}
${parameter//pattern/string}
        patterm  被扩展为一个模式，就像路径扩展中一样。parameter 被扩展，其值中最长的匹配 pattern 的内容被替换为 string。 在第
        一种形式中，只有第一个匹配被替换。第二种形式使得 pattern 中所有匹配都被替换为 string。 如果 pattern 以 #  开始，它必须
        匹配  parameter  扩展后  值的首部。如果  pattern  以  %  开始，它必须匹配  parameter  扩展后值的尾部。如果 string 是空
        值，pattern 的匹配都将被删除， pattern 之后的 / 将被忽略。如果 parameter 是 @ 或者是 *, 则替换操作将依次施用于每个位置
        参数，最后扩展为结果的列表。如果 parameter 是一个数组变量，下标是 @ 或者是 *, 模式删除将依次施用于数组中的每个成员，最
        后扩展为结果的列表。
### 命令替换

命令替换允许以命令的输出替换命令名。有两种形式：`$(command)` 和 \`command\`

Bash 进行扩展的步骤是执行 command，以它的标准输出替换它，并且将所有后续的新行符删除。内嵌的新行符不会删除，但是它们可能会在词的拆分中被删除。命令替换 `$(cat file)` 可以用等价但是更快的方法 `$(< file)` 代替。

当使用旧式的反引号（\`）替换形式时，反斜杠只有其字面意义，除非后面是 `$`, \`, 或者是 `\`。第一个前面没有反斜杠的反引号将结束命令替换。当使用 `$(command)` 形式时，括号中所有字符组成了整个命令；没有被特殊处理的字符。

命令替换可以嵌套。要在使用反引号形式时嵌套，可以用反斜杠来转义内层的反引号。

如果替换发生在双引号之中，结果将不进行词的拆分和路径扩展。

### 算术扩展

算术扩展允许算术表达式的求值和结果的替换。算术扩展的格式是：`$((expression))`

表达式 expression 被视为如同在双引号之中一样，但是括号中的双引号不会被特殊处理。表达式中所有词都经过了参数扩展，字符串扩展，命令替换和引用的删除。算术替换可以嵌套。

求值根据下面[算术求值](#算术求值)章节中列出的规则进行。如果表达式 expression 非法，bash 输出错误提示消息，不会进行替换。

### 进程替换

### 单词分割

### 路径扩展

### 引用移除

## 重定向

### 重定向输入

### 重定向输出

### 重定向输出的追加模式

## 别名

别名机制允许将一个词来替换为一个字符串，如果它是一个简单命令的第一个词的话。shell 记录着一个别名列表，可以使用内建命令 alias 和 unalias 来定义和取消（参见下面的 [内置命令](#内置命令)章节）。每个命令的第一个词，如果没有引用，都将被检查是否是一个别名。如果是，这个词将被它所指代的文本替换。别名和替换的文本可以包含任何有效的 shell 输入，包含上面列出的 metacharacters（元字符），特殊情况是别名中不能包含 `=`。替换文本的第一个词也被检查是否是别名，但是如果它与被替换的别名相同，就不会再替换第二次。这意味着可以用 ls 作为 ls -F 的别名，bash 不会递归地展开替换文本。如果别名的最后一个字符是 blank，那么命令中别名之后的下一个词也将被检查是否能进行别名展开。

别名可以使用 alias 命令来创建或列举出来，使用 unalias 命令来删除。

在替换文本中没有参数机制。如果需要参数，应当使用 shell 函数（参见下面的[函数](#函数)章节）。

如果 shell 不是交互的，别名将不会展开，除非使用内建命令 shopt 设置了 expand_aliases 选项。

关于别名的定义和使用中的规则比较混乱。Bash 在执行一行中的任何命令之前，总是读入至少完整一行的输入。别名在命令被读取时展开，而不是在执行的时候。因此，别名定义如果和另一个命令在同一行，那么不会起作用，除非读入了下一行。别名定义之后，同一行中的命令不会受新的别名影响。这种行为在函数执行时存在争议，因为别名替换是在函数定义被读取时发生的，而不是函数被执行的时候，因为函数定义本身是一个复合命令。结果，在函数中定义的别名只有当这个函数执行完才会生效。为了保险起见，应当总是将别名定义放在单独的一行，不在复合命令中使用 alias。

不管什么情况下，别名都被 shell 函数超越。

## 函数

一个 shell 函数，以上面 [shell 语法](#shell-语法)中描述的方法定义，保存着一系列的命令，等待稍后执行。当 shell 函数名作为一个简单命令名使用时，这个函数名关联的命令的序列被执行。函数在当前 shell 的上下文环境中执行；不会创建新的进程来解释它们（这与 shell 脚本的执行形成了对比）。当执行函数时，函数的参数成为执行过程中的位置参数。特殊参数 # 被更新以反映这个变化。位置参数 0 不会改变。函数执行时，FUNCNAME 变量被设置为函数的名称。函数和它的调用者在 shell 执行环境的所有其他方面都是一样的，特殊情况是 DEBUG 陷阱（参见下面对内建函数 [trap](#trap) 的描述，在 shell 内建命令章节中）不会被继承，除非函数设置了 trace 属性（参见下面对内建函数 [declare](#declare) 的描述)。

函数中的局部变量可以使用内建命令 local 来声明。通常情况下，变量和它们的值在函数和它的调用者之间是共享的。

如果函数中执行了内建命令 return，那么函数结束，执行从函数调用之后的下一个命令开始。函数结束后，位置参数的值以及特殊参数 # 都将重置为它们在函数执行前的值。

函数名和定义可以使用内建命令 declare 或 typeset 加上 -f 参数来列出。如果在 declare 或 typeset 命令中使用 -F 选项将只列出函数名。函数可以使用内建命令 export 加上 -f 参数导出，使得子 shell 中它们被自动定义。

函数可以是递归的。对于递归调用的次数没有硬性限制。

## 算术求值

在一定的环境下，shell 允许进行算术表达式的求值（参见内建命令 [let](#let) 和[算术扩展](#算术扩展)）。求值使用固定宽度的整数，不检查是否溢出，但是被零除会被捕获，标记为错误。操作数及其优先级和聚合程度与 C 语言中相同。下列操作数的列表按照相同优先级的操作数其级别来分组。列出的级别顺序是优先级递减的。

- `id++`, `id--` 变量自增，变量自减 (在后)
- `++id`, `--id` 变量自增，变量自减 (在前)
- `-`, `+` （单目的）取负，取正
- `!`, `~` 逻辑取反，位取反
- `**` 乘幂
- `*`, `/`, `%` 乘，除，取余
- `+`, `-` 加，减
- `<<`, `>>` 左移位，右移位
- `<=`, `>=`, `<`, `>` 关系运算的小于等于，大于等于，小于，大于
- `==`, `!=` 比较运算的相等，不等
- `&` 位与
- `^` 位异或
- `|` 位或
- `&&` 逻辑与
- `||` 逻辑或
- `expr? expr: expr` 条件求值
- `=`, `*=`, `/=`, `%=`, `+=`, `-=`, `<<=`, `>>=`, `&=`, `^=`, `|=` 各种赋值运算
- `expr1, expr2` 逗号表达式

shell 变量可以作为操作数；在表达式求值之前会进行参数扩展。在表达式中，可以用名称引用 shell 变量，不必使用参数扩展的语法。变量被引用时，其值被作为算术表达式来求值。shell 变量用于表达式中时，不必启用整数属性。

以 0 为前导的常量被当作八进制数，以 0x 或 0X 作为前导表明是十六进制。其他情况下，数字的形式是 [base#]n，这里 base 是一个 2 到 64 的十进制数值，作为数字的基数，n 是在这个基数中数字的值。如果忽略了 base#，将以 10 为基数。大于 10 的数字依次以小写字母，大写字母，@ 和 _ 表示。如果 base 小于或等于 36，在表示 10 与 35 之间的数字时小写字母和大写字母可以互换。

操作符根据优先级顺序进行求值。圆括号中的子表达式被最先求值，可能会超越上面的优先级规则。

**注释**

- 算术运算中的运算符以及相应的运算操作跟 C 语言一样
- 这里的算术运算是广义的，狭义的算术运算只包括加、减、乘、除和取余运算
- 其余的运算分别为关系运算，逻辑运算和位运算，等
- 控制台逐行输入下面的命令，最好先心算，然后跟运行结果比对
```bash
num=5; ((num++)); echo $num
num=5; echo $((num++)); echo $num
num=5; echo $((++num))
num=5; echo $((-num))
num=0; echo $((\!num))
num=5; echo $((~num))
num=3; echo $((num**2))
echo $((2+3))
echo $((2-3))
echo $((2*3))
echo $((2/3))
echo $((12/3))
echo $((11%3))
echo $((8>>1))
echo $((8<<1))
echo $((8<1))
echo $((8>1))
echo $((2>=3))
echo $((2<=3))
echo $((2==3))
echo $((2!=3))
echo $((2&1))
echo $((2&2))
echo $((2|1))
echo $((3^3))
echo $((3^0))
age=30; man=$((age>=20)); echo $((man?1:0))
num=10; ((num+=5)); echo $num
echo $((2+3, 2*3))
```

## 条件表达式

条件表达式用于 [[ 复合命令以及内建命令 test 和 [ 中，用来测试文件属性，进行字符串和算术比较。表达式使用下面的单目或双目操作符构造。如果某操作的任何 file 参数的形式是 `/dev/fd/n`，那么将检查文件描述符 n。如果某操作的 file 参数是 `/dev/stdin`，`/dev/stdout` 或者 `/dev/stderr` 之一，将分别检查文件描述符 0，1 和 2。

- `-a file`        如果 file 存在则为真
- `-b file`        如果 file 存在且为块设备则为真
- `-c file`        如果 file 存在且为字符设备则为真
- `-d file`        如果 file 存在且是一个目录则为真
- `-e file`        如果 file 存在则为真
- `-f file`        如果 file 存在且为普通文件则为真
- `-g file`        如果 file 存在且是设置组 ID 的 (sgid) 则为真
- `-h file`        如果 file 存在且为符号链接则为真
- `-k file`        如果 file 存在且设置了粘滞位则为真
- `-p file`        如果 file 存在且是一个命名管道 (FIFO) 则为真
- `-r file`        如果 file 存在且可读则为真
- `-s file`        如果 file 存在且大小大于零则为真
- `-t fd`          如果文件描述符 fd 是打开的且对应一个终端则为真
- `-u file`        如果 file 存在且是设置用户 ID 的 (suid) 则为真
- `-w file`        如果 file 存在且可写则为真
- `-x file`        如果 file 存在且可执行则为真
- `-O file`        如果 file 存在且为有效用户 ID 所拥有则为真
- `-G file`        如果 file 存在且为有效组 ID 所拥有则为真
- `-L file`        如果 file 存在且为符号链接则为真
- `-S file`        如果 file 存在且为套接字则为真
- `-N file`        如果 file 存在且上次读取后被修改过则为真
- `file1 -nt file2`  如果 file1 比 file2 要新 (根据修改日期)，或者 如果 file1 存在而 file2 不存在，则为真
- `file1 -ot file2`  如果 file1 比 file2 更旧，或者 如果 file1 不存在而 file2 存在，则为真
- `file1 -ef file2`  如果 file1 和 file2 指的是相同的设备和 inode 号则为真
- `-o optname`       如果启用了 shell 选项 optname 则为真。参见下面对内建命令 set 的 -o 选项的描述中的选项列表
- `-z string`        如果 string 的长度为 0 则为真
- `-n string`        如果 string 的长度非 0 则为真
- `string1 == string2`  如果字符串相等则为真。= 可以用于使用 == 的场合来兼容 POSIX 规范
- `string1 != string2`  如果字符串不相等则为真
- `string1 < string2`   如果 string1 在当前语言环境的字典顺序中排在 string2 之前则为真
- `string1 > string2`   如果 string1 在当前语言环境的字典顺序中排在 string2 之后则为真
- `arg1 OP arg2`        OP 是 `-eq`, `-ne`, `-lt`, `-le`, `-gt`, 或 `-ge` 之一。这些算术双目操作返回真，如果 arg1 与 arg2 分别是 相等，不等，小于，小于或等于，大于，大于或等于关系。 Arg1 和 arg2 可以是正/负整数

**注释：**

- 控制台逐行输入下面命令
```bash
bash
if [ -a /dev/stdin ]; then echo '/dev/stdin exist'; fi
if [ -a /dev/abc ]; then echo '/dev/abc exist'; else echo '/dev/abc not exist'; fi
```

- `cat ~/.profile` 内容如下：

  ```bash
  # if running bash
  if [ -n "$BASH_VERSION" ]; then
    # include .bashrc if it exists
    if [ -f "$HOME/.bashrc" ]; then
    . "$HOME/.bashrc"
    fi
  fi

  # set PATH so it includes user's private bin if it exists
  if [ -d "$HOME/bin" ] ; then
    PATH="$HOME/bin:$PATH"
  fi

  # set PATH so it includes user's private bin if it exists
  if [ -d "$HOME/.local/bin" ] ; then
    PATH="$HOME/.local/bin:$PATH"
  fi
  ```

- 根据上面的列表，很容易读懂脚本代码中的 `if` 判断
- `[ -n "$BASH_VERSION" ]`，检查 `$BASH_VERSION` 字符串变量是否为空
- `[ -f "$HOME/.bashrc" ]`，检查 `$HOME/.bashrc` 文件是否存在且为普通文件
- `[ -d "$HOME/bin" ]`，检查 `$HOME/bin` 是否存在，并且是一个目录
- `[ -d "$HOME/.local/bin" ]`，检查 `$HOME/.local/bin` 是否存在，并且是一个目录
- 把这些条件表达式代码的作用，跟代码前面的注释文字互相验证一下

## 简单命令扩展

当执行一个简单命令时，shell 进行下列扩展，赋值和重定向，从左到右。

1. 解释器标记为与变量赋值（在命令名之前的）和重定向有关的词被保存等待随后处理。
2. 并非变量赋值或重定向的词被扩展。如果扩展后仍然有词保留下来，第一个词被作为命令名，其余词是参数。
3. 重定向按照上面[重定向](#重定向)中讲到的规则进行。
4. 每个变量赋值中 `=` 之后的文本在赋予变量之前要经过波浪线扩展，参数扩展，命令替换，算术扩展和引用删除。

如果没有得到命令名，变量赋值影响当前 shell 环境。否则，变量被加入被执行的命令的环境中，不影响当前 shell 环境。如果任何赋值动作试图为只读变量赋值，将导致出错，命令以非零状态值退出。

如果没有得到命令名，重定向仍会进行，但是不影响当前 shell 环境。重定向出错将使命令以非零状态值退出。

如果扩展后有命令名保留下来，那么执行过程如下所示。否则，命令退出。如果在任何扩展中包含命令替换，那么整个命令的退出状态是最后一个命令替换的退出状态。如果没有进行命令替换，命令以状态零退出。

## 命令执行

命令被拆分为词之后，如果结果是一个简单命令和可选的参数列表，将执行下面的操作。

如果命令名中没有斜杠，shell 试图定位命令位置。如果存在同名的 shell 函数，函数将被执行，像上面[函数](#函数)中讲到的一样。如果名
称不是一个函数，shell 从内建命令中搜索它。如果找到对应命令，它将被执行。

如果名称既不是 shell 函数也不是一个内建命令，并且没有包含斜杠，bash 搜索 PATH 的每个成员，查找含有此文件名（可执行文件）的目录。 Bash 使用散列表来储存可执行文件的全路径（参见下面的 shell 内建命令中的 [hash](#hash)。只有在散列表中没有找到此命令，才对 PATH 进行完整的搜索。如果搜索不成功，shell 输出错误消息，返回退出状态 127。

如果搜索成功，或者命令中包含一个或多个斜杠，shell 在单独的执行环境中执行这个程序。参数 0 被设置为所给名称；命令的其他参数被设置为所给的参数，如果有的话。

如果执行失败，因为文件不是可执行格式，并且此文件不是目录，就假定它是一个 shell 脚本，一个包含 shell 命令的文件。此时将孵化出一个子 shell 来执行它。子 shell 重新初始化自身，效果就好像是执行了一个新的 shell 来处理脚本一样，但是父 shell 保存的命令位置仍然被 保留（参见下面的 shell 内建命令中的 [hash](#hash)）。

如果程序是以 #! 开头的文件，那么第一行的其余部分指定了这个程序的解释器。shell 执行指定的解释器，如果操作系统不会自行处理这种可执行文件格式的话。解释器的参数由下面三部分组成：程序第一行中解释器名称之后的可选的一个参数，程序的名称，命令行参数，如果有的话。

## 命令执行环境

shell 有执行环境的概念，由下列内容组成：

- shell 启动时继承的打开的文件，例如在内建命令 exec 中使用重定向修改的结果
- 当前工作目录，使用 cd，pushd 或者 popd 设置，或是由 shell 在启动时继承得到
- 文件创建模式掩码，使用 umask 设置或是从 shell 的父进程中继承得到
- 当前陷阱，用 trap 设置
- shell 参数，使用变量赋值或者 set 设置，或者是从父进程的环境中继承得到
- shell 函数，在执行中定义或者是从父进程的环境中继承得到
- 设为允许的选项，在执行时设置（要么是默认允许的，要么是命令行给出的）或者是用 set 设置
- 用 shopt 设为允许的选项
- 用 alias 定义的 shell 别名
- 各种进程号，包含后台作业的进程号，`$$` 的值，以及 `$PPID` 的值

当并非 shell 函数或内置命令的简单命令执行时，它在一个由下述内容组成的单独的执行环境中启动。除非另外说明，值都是从 shell 中继承的。

- shell 打开的文件，加上对命令使用重定向修改和添加的文件
- 当前工作目录
- 文件创建模式掩码
- 标记为导出的 shell 变量，以及传递到环境中为这个命令导出的变量
- shell 捕捉的陷阱被重置为从 shell 的父进程中继承的值，shell 忽略的陷阱也被忽略

在单独的环境中启动的命令不能影响 shell 的执行环境。

命令替换和异步命令都在子 shell 环境中执行。子 shell 环境是原有 shell 环境的赋值，但 shell 捕捉的陷阱被重置为 shell 启动时从父进程中继承的值。作为管道一部分来执行的内建命令也在一个子 shell 环境中执行。对子 shell 环境所作修改不能影响到原有 shell 的执行环境。

如果命令后面是 `&` 并且没有启用作业控制，命令的默认标准输入将是空文件 `/dev/null`。否则，被执行的命令从调用它的 shell 中继承被重定向修改的文件描述符。

## 环境

当一个程序执行时，它被赋予一个字符串数组，成为环境 environment。 它是一个 名称-值对 (name-value) 的列表，形式是 name=value.

shell 提供了多种操作环境的方法。启动时，shell 扫描自身的环境，为每个找到 的名字创建一个参数，自动地将它标记为 export  (向子进
程导出的)。被执行的命令继承了这个环境。 export 和 declare -x 命令允许参数和函数被加入到环境中或从环境中删除。如果环境中参数的
值 被修改，新值成为环境的一部分，替换了旧值。所有被执行的命令继承的环境 包含 shell 的初始环境 (可能值被修改过)，减去被  unset
命令删除的，加上通过 export 和 declare -x 命令添加的部分。

可以在任何  simple  command  或函数的环境中设定暂时有效的参数，只要将参数赋值放在命令前面就可以了，  参见上面 PARAMETERS 的描
述。这些赋值语句只在这个命令的环境中有效。

如果设置了内建命令 set 的 -k 选项， 所有的 变量赋值都将放到命令的环境中，不仅是在命令名前面的那些。

当 bash 执行一个外部命令时，变量 _ 被设置为命令的文件全名，然后被传递到命令的环境之中。

## 退出状态

从 shell 的角度看，一个命令退出状态是 0 意味着成功退出。退出状态是 0 表明成功。非零状态值表明失败。当命令收到 fatal signal N 退出时，bash 使用 128+N 作为它的退出状态。

如果没有找到命令，为执行它而创建的子进程返回 127。如果找到了命令但是文件不可执行，返回状态是 126。

如果命令由于扩展或重定向错误而失败，退出状态大于零。

shell 内建命令如果成功返回 0(true)，执行时出错则返回非零 (false)。所有内建命令返回 2 来指示不正确的用法。

Bash 自身返回最后执行的命令的退出状态，除非发生了语法错误，这时它返回非零值。参见下面置的内命令 [exit](#exit)。

## 信号

如果 bash 是交互的，没有设定任何陷阱，它忽略 SIGTERM（这样 kill 0 不会杀掉交互的 shell）。SIGINT 被捕获并处理（从而使内建命令 wait 可以中断）。在所有情况下，bash 忽略 SIGQUIT。如果正在使用作业控制，bash 忽略 SIGTTIN，SIGTTOU，和 SIGTSTP。

bash 开始的并行作业的信号处理句柄都设置为 shell 从父进程中继承的值。如果不是正在使用作业控制，异步命令还忽略 SIGINT 和 SIGQUIT。 作为命令替换结果运行的命令忽略键盘产生的作业控制信号 SIGTTIN，SIGTTOU，和 SIGTSTP。

如果收到信号 SIGHUP，shell 默认退出。在退出前，交互的 shell 向所有作业，运行的或停止的，发送 SIGHUP 信号。shell 向停止的作业发出 SIGCONT 信号来保证它们会收到 SIGHUP.  要阻止 shell  向特定的作业发送信号，应当使用内建命令  disown  将作业从作业表中删除（参见下面的 shell 内置命令(#内置命令)章节）或者使用 disown -h 来标记为不接受 SIGHUP。

如果使用 shopt 设置了 shell 选项 huponexit，在交互的登录 shell 退出时 bash 向所有作业发出 SIGHUP 信号。

当 bash 等待命令执行结束时，如果收到已设置了陷阱的信号，陷阱 (trap) 将不会执行，直到命令结束。当 bash 通过内建命令 wait 等待异步命令时，如果收到已设置了陷阱的信号，将使得内置命令 wait 立即以大于 128 的状态值返回。接着，陷阱将立即被执行。

## 作业控制

作业控制指的是可以选择停止（suspend，挂起）进程执行，并且可以在之后继续（resume，恢复）执行的能力。用户一般在交互的人机界面中使用这种功能。界面是由系统的终端驱动和 bash 共同提供的。

shell 将每个管道分配给一个作业。它保存一个当前运行的作业表，可以用 `jobs` 命令来列出。当 bash 启动一个异步的作业时（background，后台执行），它输出这样的一行：

`[1] 25647`

表明这个作业的作业号是 1，与作业相关连的管道中最后一个进程的进程 ID 是 15647。管道中所有进程都是同一个作业的成员。Bash 使用作业概念作为作业控制的基础。

为简化作业控制的用户界面的实现，操作系统负责管理“当前终端的进程组”的概念。这个进程组的成员（进程组 ID 是当前终端进程组 ID 的进程）可以收到键盘产生的信号，例如 SIGINT。这些进程被称为前台的。后台进程是那些进程组 ID 与终端不同的进程；这些进程不会收到键盘产生的信号。只有前台进程可以从终端读或向终端写。后台进程试图读/写终端时，将收到终端驱动程序发送的 SIGTTIN (SIGTTOU) 信号。这个信号如果没有加以捕捉，将挂起这个进程。

如果 bash 运行其上的操作系统支持作业控制，bash 会包含使用它的设施。在一个进程正在运行的时候键入挂起字符（通常是 ^Z，Control-Z）将使这个进程暂停，将控制权还给 bash。输入延时挂起字符（通常是 ^Y，Control-Y）将使这个进程在试图从终端读取输入时暂停，将控制权还给 bash.  用户接下来可以控制此作业的状态，使用 `bg` 命令使它在后台继续运行，fg 命令使它在前台继续运行，或 kill 命令将它杀死。^Z 会立即起作用，并且还有使等待中的输出和输入被忽略的附加副作用。

有很多方法来指代 shell 中的作业。字符 % 可以引入作业名。编号为 n 的作业可以用 %n 的形式来指代。作业也可以用启动它的名称的前缀，或者命令行中的子字符串来指代。例如，%ce 指代一个暂停的 ce 作业。如果前缀匹配多于一个作业，bash 报错。另一方面，使用 `%?ce`，可以指代任何命令行中包含字符串 ce 的作业。如果子字符串匹配多于一个作业，bash 报错。符号 `%%` 和 `%+` 指代 shell 意义上的当前作业，也就是前台被暂停的最后一个作业，或者是在后台启动的作业。前一作业可以使用 `%-` 来指代。在有关作业的输出信息中（例如，命令 `jobs` 的输出），当前作业总是被标记为 `+`, 前一作业标记为 `-`。

简单地给出作业名，可以用来把它放到前台：`%1` 是 `fg %1` 的同义词，将作业 1 从后台放到前台。类似的，`%1 &` 在后台恢复作业 1，与 `bg %1` 等价。

当某个作业改变状态时，shell 立即可以得知。通常，bash 等待直到要输出一个提示符时，才会报告作业的状态变化，从而不会打断其他输出。如果启用了内建命令 `set` 的 `-b` 选项，bash 将立即报告这些变化。对 SIGCHLD 信号的陷阱将在每个子进程退出时执行。

如果在作业暂停时试图退出 bash，shell 打印一条警告消息。命令 jobs 可能被用来检查作业的状态。如果再次试图退出，中间没有其他命令，shell 不会打印其他警告，暂停的作业将终止。

## 提示符

## readline 库

## 可编程补全

## 历史

## 历史扩展

## 内置命令

### let

命令格式：`let arg [arg ...]`

每个 arg 都是要求值的算术表达式（参见[算术求值](#算术求值)章节）。如果最后一个参数 arg 求值结果是 0，let 返回 1；否则返回 0。

### test

命令格式：`test expr`

`[ expr ]`

返回状态值 0 或 1，根据条件表达式 expr 的求值而定。每个操作符和操作数都必须是一个单独的参数。表达式使用上面[条件表达式](#条件表达式)中的操作构造。

表达式可以用下列操作符结合，以优先级的降序列出。

- `! expr`          值为真，如果 expr 为假。
- `( expr )`        返回 expr 的值。括号可以用来超越操作符的一般优先级。
- `expr1 -a expr2`  值为真，如果 expr1 和 expr2 都为真。
- `expr1 -o expr2`  值为真，如果 expr1 或 expr2 为真。

test 和 [ 使用基于参数个数的一系列规则，对条件表达式进行求值。

- `0 arguments`     表达式为假。
- `1 argument`      表达式为真，当且仅当参数非空。
- `2 arguments`     如果第一个参数是 !，表达式为真，当且仅当第二个参数为空。如果第一个参数是上面[条件表达式](#条件表达式)中列出的单目条件运算符之一，表达式为真，当且仅当单目测试为真。如果第一个参数不是合法的单目条件运算符，表达式为假。
- `3 arguments`     如果第二个参数是上面[条件表达式](#条件表达式)中列出的双目条件操作符之一，表达式的结果是使用第一和第三个参数作为操作数的二进制测试的结果。如果第一个参数是 !，表达式值是使用第二和第三个参数进行双参数测试的结果取反。如果第一个参数是 `(`，第三个参数是 `)`，结果是对第二个参数进行单参数测试的结果。否则，表达式为假。这种情况下 -a 和 -o 操作符被认为二进制操作符。
- `4 arguments`     如果第一个参数是 !，结果是由剩余参数组成的三参数表达式结果取反。否则，表达式被根据上面列出的优先级规则解释并执行。
- `5 或更多 arguments`  表达式被根据上面列出的优先级规则解释并执行。

### times

times 对 shell 以及 shell 运行的进程，打印累计的用户和系统时间。返回状态是 0。

## 受限的 shell


## 扩展阅读

- `man zsh`

