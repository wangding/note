# bash 学习笔记

全文参考 bash 手册，阅读原文：`man bash`。笔记只摘录个人感兴趣的内容，个人的理解放到注释下面。

## 名称

bash - GNU Bourne-Again SHell (GNU 命令解释程序 “Bourne二世”)

## 概述

bash [options] [file]

注释：
- bash 完整的命令行格式为，bash [长选项] [短选项] [脚本文件名]
- 长选项要放到短选项之前，参考：`bash --help`，以及下面的[选项](#选项)小节。

## 描述

Bash 是一个与 sh 兼容的命令解释程序，可以执行从标准输入或者文件中读取的命令。

注释：
- 直接在命令行输入 `sh`，进入交互式的 sh
- 输入 `ls` 和 `exit` 两个命令，跟 bash 下的体验差不多
- sh 是 Bourne Shell，Bourne 一代；而 bash 是 Bourne 二代

## 选项

### 长选项

--help      在标准输出显示用法信息并成功退出
--version   在标准输出显示此 bash 的版本信息并成功退出

注释：
- 命令行运行 `bash --help` 和 `bash --version`
- 命令行运行 `bash -c help` 获取帮助信息
- 命令行输入 `bash`，进入交互模式后，再输入 `help` 查看帮助信息
- zsh 下面不支持 `help` 命令

### 短选项

-c string   如果有 -c 选项，那么命令将从 string 中读取。如果 string 后面有参数 (argument)，它们将用于给位置参数 (positional
            parameter，以 $0 起始) 赋值。

-i          如果有 -i 选项，shell 将交互地执行。

注释：
- 命令行运行 `bash -c "ls -l"`
- 不用 `-i` 选项，命令行直接运行 `bash`，就会进入交互式的 Shell
- 关键是要知道 Shell 分为交互式和非交互式
- 交互式 Shell，就是对话模式，输入：命令，输出：命令执行的结果，输入和输出是一问一答，就是交互式
- 非交互式 Shell，就是批处理模式或脚本模式，输入：脚本文件，输出：脚本文件执行的结果
- 这个手册即讲解交互式的 Shell，也讲解非交互式的 Shell，也就是 Shell 编程

## 参数

略

## 启动

当 bash 是作为交互的登录 shell 启动的，或者是一个非交互的 shell 但是指定了 --login 选项，它首先读取并执行 /etc/profile 中的
命令，只要那个文件存在。读取那个文件之后，它以如下的顺序查找 ~/.bash_profile, ~/.bash_login, 和 ~/.profile, 从存在并且可读的
第一个文件中读取并执行其中的命令。 --noprofile 选项可以用来在 shell 启动时阻止它这样做。

当一个登录 shell 退出时， bash 读取并执行文件 ~/.bash_logout 中的命令，只要它存在。

当一个交互的 shell 但不是登录 shell 启动时，bash 从文件 ~/.bashrc 中读取并执行命令，只要它存在。可以用 --norc 选项来阻止它这
样做。 --rcfile file 选项将强制 bash 读取并执行文件 file 中的命令，而不是 ~/.bashrc 中的。

注释：
- `cat /etc/profile`，查看 profile 文件内容
- `cat ~/.profile`，查看 .profile 文件内容
- `cat ~/.bash_logout`，查看 .bash_logout 文件内容
- 修改 .bashrc 文件，在其中添加 `echo wangding`
- 命令行运行 `bash`，进入 bash 交互模式，看到输出 `wangding`

## 定义

略

## 保留字

保留字是对 shell 有特殊意义的词. 下列词被识别为保留的, 如果不是引用, 并且不是一个简单命令的起始词, 也不是 case 或者 for 命令的第三个词:

`! case do done elif else esac fi for function if in select then until while { } time [[ ]]`

注释：
- 学过编程的人都知道，保留字就是编程语言中的关键字，保留字不允许用作变量名或函数名。

## shell 语法

注释：
- shell 语法中的简单命令、管道命令、列表命令和复合命令
- 类似编程中的变量和运算符、表达式、语句和语句块之间的层次关系
- 多个简单命令通过管道操作符可以连接成管道命令
- 多个简单命令或者多个管道命令又组成列表命令
- 多个列表命令又组成复合命令
- 从编程语言的语法角度来理解这些概念，会简单和容易很多
- 站在编程语言的语法角度，shell 语法不是什么新鲜玩意

### 简单命令

注释：
- 简单命令就是一个命令，格式为：`command [options] [arguments]`

### 管道命令

管道是一个或多个命令的序列，用字符 | 分隔。管道的格式是这样:

`[time [-p]] [ ! ] command [ | command2 ... ]`

命令 command 的标准输出通过管道连接到命令 command2 的标准输入。连接是在命令指定的任何重定向之前进行的。

如果保留字 ! 作为管道前缀，管道的退出状态将是最后一个命令的退出状态的逻辑非值。否则，管道的退出状态就是最后一个命令的。

如果保留字 time 作为管道前缀，管道中止后将给出执行管道耗费的用户和系统时间。

注释：
- time 用来做基准测试
- `!` 是编程语言中的取反操作
- 在命令行输入 `! ls` 和 `echo $?`
- 在命令行输入 `ls` 和 `echo $?`
- unix 的哲学是小而美，每个命令的功能单一
- 通过管道操作把多个简单命令连接起来，完成一个复杂功能，下面的管道命令用来计算代码行数
- `find . -name '*.js' ! -path "./**/node_modules/*" ! -path "./node_modules/*" | xargs cat | grep -v ^$ | wc -l`
- 完成文本行的排序和去重：`cat data.txt | sort | uniq`

### 列表命令 list

列表命令是一个或多个管道，用操作符 ;, &, &&, 或 ⎪⎪ 分隔的序列, 并且可以选择用 ;, &, 或 <newline>新行符结束.

这些序列操作符中， && 和 ⎪⎪ 优先级相同，其次是 ; 和 &, 它们的优先级是相同的。

序列中可以有一个或多个新行符来分隔命令，而不是使用分号分隔。

如果一个命令是由控制操作符 & 结束的, shell 将在后台的子 shell 中执行这个命令。

shell 不会等待命令执行结束，返回状态总是 0。以分号 ; 分隔的命令会被顺序执行；

shell 会等待每个命令依次结束。返回状态是最后执行的命令的返回状态。

控制操作符 && 和 ⎪⎪ 分别代表 AND 和 OR 序列。

一个 AND 序列的形式是：`command1 && command2`

command2 只有在 command1 返回 0 时才被执行。

一个 OR 序列的形式是；`command1 ⎪⎪ command2`

command2 只有在 command1 返回非 0 状态时才被执行。AND 和 OR 序列的返回状态是序列中最后执行的命令的返回状态。

注释：
- bash 的语法跟 C 语言的语法如出一辙，三种逻辑运算：取反 !，与 &&，或 ||，还有分号的语句结尾
- 结合下面的复合命令描述，列表命令其实就是命令组成的语句块
- 命令行执行两个列表命令：`pwd; echo '-------'; ls;` 和 `pwd; ls | sort;`
- 根据手册描述，上面两个列表命令，最好用新行来隔开两个命令，这样就成交互模式了，但是放到脚本里面没有问题
- & 符号放到命令末尾，这个命令将在后台运行
- `vim &` vim 在后台运行，其实是挂起状态，`fg` 可以把 vim 调到前台
- 关于 && 和 || 两种列表命令的执行方式，执行以下的操作来体会一下
- 命令行执行：`pwd && ls`，`! pwd && ls` 观察两者的区别
- 命令行执行：`pwd || ls`，`! pwd || ls` 观察两者的区别

### 复合命令

复合命令是如下情况之一：

(list)

列表命令将在一个子 shell 中执行。变量赋值和影响 shell 环境变量的内建命令在命令结束后不会再起作用。返回值是序列的返回值。

{ list; }

列表命令将在当前 shell 环境中执行。序列必须以一个新行符或分号结束。这种做法也称为 group command(命令组)。返回值是序

列的返回值。注意与元字符 ( 和 ) 不同， { 和 } 是保留字，必须出现在能够识别保留字的场合。由于它们不会

产生断词(cause a word break)，它们和序列之间必须用空格分开。

((expression))

表达式 expression 将被求值。求值规则在下面的算术求值章节中描述。如果表达式的值非零，返回值就是 0；否则返回值是 1。

[[ expression ]]

返回 0 或 1，取决于条件表达式 expression 求值的情况。 表达式是由下面 CONDITIONAL EXPRESSIONS 条件表达式 章节中描述的原
语(primaries) 组成。 [[ 和 ]] 中的词不会进行词的拆分和路径的扩展处理； 而tilde  扩展，参数和变量扩展，算术扩展，命令替
换，函数替换和引用的去除则都将进行。

当使用  ==  和 != 操作符时，操作符右边的字符串被认为是一个模式，根据下面 Pattern Matching(模式匹配) 章节中的规则进行匹
配。 如果匹配则返回值是 0，否则返回 1。模式的任何部分可以被引用，强制使它作为一个字符串而被匹配。

表达式可以用下列操作符结合起来。根据优先级的降序列出如下：

( expression ) 返回表达式 expression 的值。括号可以用来提升操作符的优先级。

! expression   返回真，如果表达式 expression 返回假。

expression1 && expression2  返回真，如果表达式 expression1 和 expression2 都返回真。

expression1 || expression2  返回真，如果表达式 expression1 或者 expression2 二者之一返回真。

&&(与) 和 || 操作符不会对表达式 expression2 求值，如果 expression1 可以决定整个条件表达式的返回值的话。

for name [ in word ] ; do list ; done

in 之后的一系列词会被扩展，产生一个项目列表。变量 name 被依次赋以这个列表中的每个元素， 序列  list  每次都被执行。如果
in  word 被忽略，那么 for 命令遍历 已设置的位置参数(positional parameter，参见下面的 PARAMETERS 参数)， 为每一个执行一
次序列 list。 返回值是最后一个命令的返回值。如果 in 之后的词扩展的结果是空列表，就不会执行任何命令，返回值是 0。

for (( expr1 ; expr2 ; expr3 )) ; do list ; done

首先，算术表达式 expr1 被根据下面 算术求值 (ARITHMETIC EVALUATION) 中的规则进行求值。  然后算术表达式  expr2  被循环求
值，直到它等于  0。每次 expr2 结果非零时，序列 list 都被执行， 算术表达式 expr3 被求值。如果任何表达式被忽略，将被视为
执行结果是 1。 返回值是序列 list 中被执行的最后一个命令的返回值；或者是 false，如果任何表达式非法的话。

select name [ in word ] ; do list ; done

in 之后的一系列词会被扩展，产生一个项目列表。这个扩展后的词集合被输出到标准错误上，每个前面 加上一个数字。如果 in word
被忽略，将输出位置参数 (参见下面的 PARAMETERS 参数 章节)。 PS3 提示符将被显示出来，等待从标准输入得到一行输入。如果 输
入是一个数字且显示中有对应的词，那么变量 name 的值将设置为这个词。如果输入一个空行，那么词和提示符将再次显示出来。如果
读入了一个 EOF，命令就结束。 任何其他值将设置变量 name 为空。读入的行保存为变量 REPLY.  序列 list 在每次选择之后都会执
行，直到执行了一个 break 命令。 select 的退出状态是序列 list 中执行的最后一个命令的退出状态，如果没有执行命令就是 0。

case word in [ [(] pattern [ | pattern ] ... ) list ;; ] ... esac

case  命令首先扩展  word,  然后依次试着用每个  pattern  来匹配它，  使用与路径扩展相同的匹配规则(参见下面的   Pathname
Expansion  路径扩展 章节)。如果找到一个匹配，相应的序列将被执行。找到一个匹配之后，不会再尝试其后的匹配。 如果没有模式
可以匹配，返回值是 0。否则，返回序列中最后执行的命令的返回值。

if list; then list; [ elif list; then list; ] ... [ else list; ] fi

序列 if list 被执行。如果退出状态是 0，then list 将被执行。否则，每个 elif 将被一次执行，如果退出状态是 0，相应的 then
list  将被执行，命令结束。 否则，else list 将被执行，如果存在的话。 退出状态是最后执行的命令的退出状态，或者是 0，如果
所有条件都不满足。

while list; do list; done
until list; do list; done

while 命令不断地执行序列 do list，直到序列中最后一个命令返回 0。 until 命令和  while  命令等价，除了对条件的测试恰好相
反；序列 do list 执行直到序列中最后一个命令返回非零状态值。 while 和 until 命令的退出状态是序列 do list 中最后一个命令
的退出状态， 或者是 0，如果没有执行任何命令。

[ function ] name () { list; }

这样可以定义一个名为 name 的函数。函数体 body 是包含在 { 和 } 之间的命令序列 list。 在指定将 name 作为一个命令运行的场

合，这个序列将被执行。函数的退出状态是函数体最后执行的命令的退出状态。

注释：

- 如果对 Shell 编程不感兴趣，复合命令可以不看
- 如果有编程基础，复合命令没有什么难度，就是分支和循环两种流程控制

## 注释

`#` 开头行都被忽略，通常用在非交互模式。交互模式下，使用内建命令 shopt 启用了 interactive_comments 选项，`#` 也起注释作用。

注释：

- 交互模式下 interactive_comments 选项默认是启用的
- zsh 的交互模式也是启用的
- 会放到历史命令里，执行下面的操作，体会一下
- `#ls`, `history` 会看到 `#ls` 命令, `ctrl+r ls` 会调出历史命令

## 引用

## 参数

### 位置参数

### 特殊参数

### Shell 内置变量

### 数组

## 扩展

### 花括号扩展

### Tilde 扩展

### 参数扩展

### 命令替换

### 算数扩展

### 进程替换

### 单词分割

### 路径扩展

### 引用移除

## 重定向

### 重定向输入


### 重定向输出

### 重定向输出的追加模式

## 别名

## 函数

## 算数求值

## 条件表达式

## 简单命令扩展

## 命令执行

## 命令执行环境

## 环境

## 退出状态

## 信号

## 作业控制


## 提示符

## readline 库

## 可编程补全


## 历史

## 历史扩展


## 内置命令

## 扩展阅读

- `man zsh`

