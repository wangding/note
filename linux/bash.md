# bash 学习笔记

**注释：**

- 全文参考 bash 手册，阅读原文：`man bash`
- 笔记只摘录个人感兴趣的内容，个人的理解放到注释下面
- 注释文字中，控制台输入 `ls -l`，`ls -l` 是命令字符串，默认后面输入回车键，下文不再赘述
- 如果想查看中文手册，ubuntu 安装方式：`sudo apt install manpages-zh`
- 感谢中文 man 翻译计划，github 仓库地址：`https://github.com/man-pages-zh/manpages-zh`

## 名称

bash - GNU Bourne-Again SHell (GNU 命令解释程序 “Bourne 二世”)

## 描述

Bash 是一个与 sh 兼容的命令解释程序，可以执行从**标准输入**或者**文件**中读取的命令。

**注释：**

- 直接在控制台输入 `sh`，进入交互式的 sh
- 输入 `ls` 和 `exit` 两个命令，跟 bash 下的体验差不多
- sh 是 Bourne Shell，Bourne 一代；而 bash 是 Bourne 二代

## 概述

`bash [options] [file]`

**注释：**

- bash 完整命令行格式为：`bash [长选项] [短选项] [脚本文件名]`
- 长选项要放到短选项之前，参考：`bash --help`，以及下面的[选项](#选项)章节

## 选项

### 长选项

`--help`      在标准输出显示用法信息并成功退出

`--version`   在标准输出显示此 bash 的版本信息并成功退出

**注释：**

- 控制台输入 `bash --help`，查看 bash 的帮助信息
- 控制台输入 `bash --version`，查看 bash 的版本信息

### 短选项

`-c string`   如果有 -c 选项，那么命令将从 string 中读取。如果 string 后面有参数，它们将用于给位置参数（位置参数以 $0 起始）赋值。

`-i`          如果有 -i 选项，shell 将交互地执行。

**注释：**

- 不用 `-i` 选项，控制台输入 `bash`，默认就会进入交互式的 Shell
- 所以 `-i` 选项的用处不大，关键是要知道 Shell 分为**交互模式**和**非交互模式**
- `-c` 选项，`c` 代表 command，`-c string` 是非交互式运行 string 中的命令
- 控制台输入 `bash -c "ls -l"`，查看当前目录下的内容，当然不如 `ls -l` 来的直接
- 控制台输入 `bash -c help` 获取帮助信息，`help` 是 bash 内置命令，zsh 不支持 `help` 内置命令
- node 和 python 作为脚本解释器，跟 bash 命令解释器的用法类似，下面是两个非交互模式
- `node -e "console.log('Hello, nodejs world!')"`，类似 `bash -c "echo 'Hello, bash world!'`
- `python3 -c "print('Hello, python world!')"`，类似 `bash -c "echo 'Hello, bash world!'`
- 交互模式，就是对话模式，输入命令，输出命令执行的结果，输入和输出是一问一答，就是交互模式
- 控制台输入 `bash`，进入交互模式后，输入 `help` 查看帮助信息，`exit` 退出交互模式
- 控制台输入 `bash`，输入 `echo "Hello, bash world!"`，输入 `pwd`，输入 `ls`，输入 `exit`
- 非交互模式，就是批处理模式或脚本模式，输入脚本文件，输出脚本文件执行的结果
- 这个手册即有交互式 Shell 的用法，也有非交互式 Shell 的用法，也就是 Shell 编程
- 编写一个简单的脚本文件 `hello.sh` 内容如下：
```bash
echo 'Hello, bash world!'
echo 'I am wangding.'
```
- 控制台输入 `bash hello.sh`，以非交互模式运行 `hello.sh` 脚本文件，bash 是脚本解释器
- 如果有 nodejs 或 python 脚本编程的经验，bash 的两种运行方式很容易理解
- `node hello.js`，以非交互模式运行 `hello.js` 脚本文件，可以做 `bash hello.sh` 类似的事情
- `python3 hello.py`，以非交互模式运行 `hello.py` 脚本文件，可以做 `bash hello.sh` 类似的事情
- `node` 和 `python3` 进入交互模式，跟 `bash` 交互模式类似，用 `exit` 退出交互模式
- bash 是鼻祖，nodejs 和 python 参考和借鉴 bash 是肯定的

`-r`          如果有 -r 选项，shell 成为受限的（参见下面的[受限的 shell](#受限的-shell) 章节）。

`-s`          如果有 -s 选项，或者如果选项处理完以后，没有参数剩余，那么命令将从标准输入读取。这个选项允许在启动一个交互 shell 时可以设置位置参数。

`[-+]O [shopt_option]` shopt_option 是一个 shopt 内置命令可接受的选项（参见下面的[内置命令](#内置命令)章节）。如果有 shopt_option，-O 将设置那个选项的取值；+O 取消它。如果没有给出 shopt_option，shopt 将在标准输出上打印设为允许的选项的名称和值。

`--`          -- 标志选项的结束，禁止其余的选项处理。任何 -- 之后的参数将作为文件名和参数对待。参数 - 与此等价。

**注释：**

- `-r` 用处不大，知道有受限 Shell，了解一下受限 Shell 有哪些功能被阉割了就行
- `-s` 用处不大，关于参数位置，`-c string` 选项中也提到了，执行下面的操作就明白了
```bash
bash -s 1 2
echo $0
echo $1
echo $2
```
- 脚本文件执行时，也可以有命令行参数，编写包含上面三个 echo 命令的脚本文件 `parameters.sh`
- 控制台输入 `bash parameters.sh 1 2`，查看输出结果，注意 $0 代表的是脚本文件本身
- `[-+]O [shopt_option]` 这个选项可以设置或查看 bash 参数，不同的参数控制 bash 的不同行为
- 控制台输入 `bash -O`，列出 bash 所有参数，并进入 bash 交互模式，on 为参数开启状态，off 为参数关闭状态
- 以 interactive_comments 参数为例，`interactive_comments on`，这个参数默认为开启状态，允许命令行注释
- 输入 `#ls`，控制台没有报错，`#` 后面的内容视为注释，bash 直接忽略，`exit` 退出 bash 交互模式
- 关闭 interactive_comments 参数，控制台执行 `bash +O interactive_comments`，进入 bash 交互模式
- 控制台输入 `shopt` 查看 bash 所有参数状态，看到 `interactive_comments off`
- 控制台输入 `#ls`，提示 `找不到命令 “#ls”`，说明此时 bash 不支持控制台的 `#` 注释行为

## 参数（arguments）

如果选项处理之后仍有参数剩余，并且没有指定 -c 或 -s 选项，第一个参数将假定为一个包含 shell 命令的文件的名字。

如果 bash  是以这种方式启动的，$0 将设置为这个文件的名字，位置参数将设置为剩余的其他参数。

Bash 从这个文件中读取并执行命令，然后退出。Bash 的退出状态是脚本中执行的最后一个命令的退出状态。如果没有执行命令，退出状态是 0。

尝试的步骤是先试图打开在当前目录中的这个文件，接下来，如果没有找到，shell 将搜索脚本的 PATH 环境变量中的路径。

**注释：**

- 编写 parameters.sh 内容如下：
```bash
echo $0
echo $1
echo $2
```
- 控制台输入 `bash parameters.sh 1 2`，观察输出内容，$0 表示 parameters.sh，$1 是 1，$2 是 2

## 启动

当 bash 是作为交互的登录 shell 启动的，或者是一个非交互的 shell 但是指定了 `--login` 选项，它首先读取并执行 `/etc/profile` 中的命令，只要那个文件存在。读取那个文件之后，它以如下的顺序查找 `~/.bash_profile`，`~/.bash_login`，和 `~/.profile`，从存在并且可读的第一个文件中读取并执行其中的命令。`--noprofile` 选项可以用来在 shell 启动时阻止它这样做。

当一个登录 shell 退出时， bash 读取并执行文件 `~/.bash_logout` 中的命令，只要它存在。

当一个交互的 shell 但不是登录 shell 启动时，bash 从文件 `~/.bashrc` 中读取并执行命令，只要它存在。可以用 `--norc` 选项来阻止它这
样做。`--rcfile file` 选项将强制 bash 读取并执行文件 file 中的命令，而不是 `~/.bashrc` 中的。

**注释：**

- `cat /etc/profile`，查看 `/et/profile` 文件内容，暂时看不懂没关系，把这个文档都学完了，自然就懂了
- `cat ~/.profile`，查看 `~/.profile` 文件内容
- `cat ~/.bash_logout`，查看 `~/.bash_logout` 文件内容
- 打造酷炫的登录欢迎信息，`sudo apt install screenfetch`
- 修改 .bashrc 文件，在其中添加 `screenfetch 2>/dev/null`
- 控制台输入 `bash`，进入 bash 交互模式，看到 screenfetch 输出，有 Linux 发行版的 Logo 及系统信息
- 另一种可选方案是使用 fortune，登录后显示名言和古诗词

## 定义

下列定义在文档余下部分中通用。

`blank` 空白

一个空格或是 tab

`word` 词

一个字符序列，shell 将它们视为一个结构单元，也称为一个 token 片段。

`name` 名称

一个只由字母，数字和下划线构成的词，并且以字符或下划线起始，也称为一个标识符。

`metacharacter` 元字符

一个字符，如果不是引用的话，将成为词的分隔符。它是这些字符之一：`|  & ; ( ) < > space tab`

`control operator` 控制操作符

一个标识，拥有控制功能。它是这些符号之一：`|| & && ; ;; ( ) | <newline>`

**注释：**

- 这些术语是下面描述 Shell 编程语法时会用到的，如果对 Shell 编程不感兴趣这些可以忽略
- 如果有 C 语言或者其他高级语言的编程经验，部分元字符和控制操作符的作用跟编程语言是类似的
- `name` 名称相当于编程语言中的变量名和函数名，即标识符
- `metacharacter` 如果不是引用，将成为词的分隔符，下面逐一介绍每个符号
- `|` 是管道操作符，它可以把多个简单命令连接组合成复杂功能的管道命令
- 管道操作符是个非常强大的功能，手册后面还会详细介绍
- `&` 用途很多，放到命令后面时，命令被放到后台运行，也可以用在重定向，后面会详细介绍
- `;` 类似 C 语言中语句的分隔符，也是 for 循环中，循环变量初始化、递增和退出条件的分隔符
- `()` 类似 C 语言中的 if、switch、 while 等条件表达式的用法
- `< >` 用于重定向，或在条件表达式中表示小于和大于
- `control operator` 控制操作符，拥有控制功能，下面逐一介绍每个符号
- `||` 类似 C 语言中逻辑或运算
- `&&` 类似 C 语言中的逻辑与运算
- 其他控制操作符在元字符中提到了，用法类似，就不再赘述了

## 保留字

保留字是对 shell 有特殊意义的词。下列词被识别为保留的，如果不是引用，并且不是一个简单命令的起始词（参见下面的[Shell 语法](#Shell-语法)），也不是 case 或者 for 命令的第三个词：

`! case do done elif else esac fi for function if in select then until while { } time [[ ]]`

**注释：**

- 学过编程的人都知道，保留字就是编程语言中的关键字，保留字不允许用作变量名或函数名
- 大部分这些保留字跟 C 语言中的关键字用法相同

## shell 语法

**注释：**

- 这个章节的内容尤其是复合命令，涉及 Shell 非交互模式，即 Shell 编程的内容
- shell 语法中的简单命令、管道命令、列表命令和复合命令
- 类似编程语言中的变量和运算符、表达式、语句和语句块之间的层次关系
- 多个简单命令通过管道操作符可以连接成管道命令
- 多个简单命令或者多个管道命令又组成列表命令
- 多个列表命令又组成复合命令
- 从编程语言的语法角度来理解这些概念，会简单和容易很多
- 站在编程语言的语法角度，shell 语法不是什么新鲜玩意

### 简单命令

简单命令是（可选的）一系列变量赋值，紧接着是空格分隔的词和重定向，然后以一个控制操作符结束。

第一个词指明了要执行的命令，它被作为第 0 个参数。其余词被作为这个命令的参数。

简单命令的返回值是它的退出状态，或是 128+n，如果命令被信号 n 结束的话。

**注释：**

- 说人话，简单命令就是一个命令，格式为：`command [options] [arguments]`
- 命令字符串是第 0 个参数，即 $0，后续的选项和参数用空格分割
- 关于退出码，正常退出是 0。异常退出，在控制台依次输入下面的命令：
```bash
z note
gitbook serve --port 8080
ctrl + c
echo $?
```
- 退出码是 130，`ctrl + c` 的信号是 `SIGINT` 信号的值 n 是 2，所以退出码是 `128+2 = 130`
- 查看信号的资料，输入命令：`man 7 signal`

### 管道命令

管道是一个或多个命令的序列，用字符 | 分隔。管道的格式是这样:

`[time [-p]] [ ! ] command [ | command2 ... ]`

命令 command 的标准输出通过管道连接到命令 command2 的标准输入。连接是在命令指定的任何重定向之前进行的。

如果保留字 ! 作为管道前缀，管道的退出状态将是最后一个命令的退出状态的逻辑非值。否则，管道的退出状态就是最后一个命令的。

如果保留字 time 作为管道前缀，管道中止后将给出执行管道耗费的用户和系统时间。

**注释：**

- time 用来做基准测试，返回命令运行的时长，单位是秒
- zsh 的 time 输出结果，格式有些混乱
- 通过 time 可以很方便的做基准测试，例如：比较 nodejs 和 python 解释器的速度
- 在控制台输入 `bash`，进入交互模式后，在控制台输入下面两个命令
```bash
time node -e "console.log('helo')"
time python3 -c "print('hello')"
```
- 基准测试结果，应该是 python 解释器的速度更快
- 注意 time 不是内置命令，应该是 Bash 保留关键字，控制台输入：`which time` 验证一下
- 类似的内置命令是 times，控制台输入：`which times` 验证一下
- `/usr/bin/time` 同样是做基准测试的工具，功能要更强大一些，控制台输入下面两个命令
```bash
/usr/bin/time -v node -e "console.log('hello')"
/usr/bin/time -v python3 -c "print('hello')"
```
- `!` 是逻辑非值，跟 C 语言中的取反逻辑运算相同
- 在控制台输入 `ls` 和 `echo $?`
- 在控制台输入 `! ls` 和 `echo $?`
- unix 的哲学是小而美，每个命令的功能单一
- 通过管道操作把多个简单命令连接起来，完成一个复杂功能
- 例如：下面的管道命令，用来计算某个目录下 JavaScript 文件的代码行数
- `find . -name '*.js' ! -path "./**/node_modules/*" ! -path "./node_modules/*" | xargs cat | grep -v ^$ | wc -l`
- 现代化图形界面的 IDE，很少提供类似的代码行数统计功能，可见 bash 的强大，以及顽强的生命力
- 例如：完成文本行的排序和去重，控制台输入：`cat data.txt | sort | uniq`

### list 命令

list 命令是一个或多个管道。用操作符 ;，&，&&，或 ⎪⎪ 分隔的序列，并且可以选择用 ;，&，或新行符结束。

这些 list 操作符中，&& 和 ⎪⎪ 优先级相同，其次是 ; 和 &，它们的优先级是相同的。

list 中可以有一个或多个新行符来分隔命令，而不是使用分号分隔。

如果一个命令是由控制操作符 & 结束的，shell 将在后台的子 shell 中执行这个命令。shell 不会等待命令执行结束，返回状态总是 0。以分号 ; 分隔的命令会被顺序执行；shell 会等待每个命令依次结束。返回状态是最后执行的命令的返回状态。

控制操作符 && 和 ⎪⎪ 分别代表 AND 和 OR 序列。

一个 AND 序列的形式是：`command1 && command2`，command2 只有在 command1 返回 0 时才被执行。

一个 OR 序列的形式是：`command1 ⎪⎪ command2`，command2 只有在 command1 返回非 0 时才被执行。

AND 和 OR 序列的返回状态是 list 中最后执行的命令的返回状态。

**注释：**

- 三种逻辑运算：取反 !，与 &&，或 ||，还有分号的语句结尾，Shell 语法跟 C 语法如出一辙
- 结合下面的复合命令描述，list 命令其实就是命令组成的语句块
- 控制台执行两个列表命令：`pwd; echo '-------'; ls;` 和 `pwd; ls | sort;`
- 根据手册描述，上面两个 list 命令，最好用新行来隔开两个命令
- 这两个 list 命令，之所以没有这样做，是因为用新行，就成交互模式了
- 但是放到脚本里面是没有问题，例如：脚本文件 `list.sh` 内容如下：
```bash
pwd
echo '--------------'
ls -l
```
- 控制台输入：`bash list.sh`
- & 符号放到命令末尾，这个命令将在后台运行，注意是否为挂起状态，挂起的进程不会执行
- `vim &` vim 在后台运行，是挂起状态，`fg` 可以把 vim 调到前台
- 关于 && 和 || 两种列表命令的执行方式，执行以下的操作来体会一下
- 控制台输入：`pwd && ls` 和 `! pwd && ls` 观察两者的区别
- 控制台输入：`pwd || ls` 和 `! pwd || ls` 观察两者的区别

### 复合命令

复合命令是如下情况之一：

`(list)`

list 命令将在一个子 shell 中执行。变量赋值和影响 shell 环境变量的内建命令在命令结束后不会再起作用。返回值是序列的返回值。

`{ list; }`

list 命令将在当前 shell 环境中执行。序列必须以一个新行符或分号结束。这种做法也称为命令组。返回值是序列的返回值。注意与元字符 ( 和 ) 不同， { 和 } 是保留字，必须出现在能够识别保留字的场合。由于它们不会产生断词，它们和序列之间必须用空格分开。

`((expression))`

表达式 expression 将被求值。求值规则在下面的[算术求值](#算术求值)章节中描述。如果表达式的值非零，返回值就是 0；否则返回值是 1。这种做法和 let "expression" 等价。

`[[ expression ]]`

返回 0 或 1，取决于条件表达式 expression 求值的情况。表达式是由下面[条件表达式](#条件表达式)章节中描述的原语组成。[[ 和 ]] 中的词不会进行词的拆分和路径的扩展处理；而 tilde 扩展，参数和变量扩展，算术扩展，命令替换，函数替换和引用的去除则都将进行。

当使用 == 和 != 操作符时，操作符右边的字符串被认为是一个模式，根据下面[模式匹配](#模式匹配)章节中的规则进行匹配。如果匹配则返回值是 0，否则返回 1。模式的任何部分可以被引用，强制使它作为一个字符串而被匹配。

表达式可以用下列操作符结合起来。根据优先级的降序列出：

- `( expression )` 返回表达式 expression 的值。括号可以用来提升操作符的优先级
- `! expression` 返回真，前提是表达式 expression 返回假
- `expression1 && expression` 返回真，前提是表达式 expression1 和 expression2 都返回真。
- `expression1 || expression2` 返回真，前提是表达式 expression1 或者 expression2 二者之一返回真。

&& 和 || 操作符不会对表达式 expression2 求值，前提是 expression1 可以决定整个条件表达式的返回值。

`for name [ in word ] ; do list ; done`

in 之后的一系列词会被扩展，产生一个项目列表。变量 name 被依次赋以这个列表中的每个元素，序列 list 每次都被执行。如果 in  word 被忽略，那么 for 命令遍历已设置的位置参数（参见下面的[参数](#参数)章节），为每一个执行一次序列 list。返回值是最后一个命令的返回值。如果 in 之后的词扩展的结果是空列表，就不会执行任何命令，返回值是 0。

`for (( expr1 ; expr2 ; expr3 )) ; do list ; done`

首先，算术表达式 expr1 被根据下面[算术求值](#算术求值)中的规则进行求值。然后算术表达式  expr2  被循环求值，直到它等于 0。每次 expr2 结果非零时，序列 list 都被执行，算术表达式 expr3 被求值。如果任何表达式被忽略，将被视为执行结果是 1。返回值是序列 list 中被执行的最后一个命令的返回值；或者是 false，如果任何表达式非法的话。

`select name [ in word ] ; do list ; done`

in 之后的一系列词会被扩展，产生一个项目列表。这个扩展后的词集合被输出到标准错误上，每个前面加上一个数字。如果 in word 被忽略，将输出位置参数（参见下面的[参数](#参数)章节）。PS3 提示符将被显示出来，等待从标准输入得到一行输入。如果输入是一个数字且显示中有对应的词，那么变量 name 的值将设置为这个词。如果输入一个空行，那么词和提示符将再次显示出来。如果读入了一个 EOF，命令就结束。任何其他值将设置变量 name 为空。读入的行保存为变量 REPLY，序列 list 在每次选择之后都会执行，直到执行了一个 break 命令。select 的退出状态是序列 list 中执行的最后一个命令的退出状态，如果没有执行命令就是 0。

`case word in [ [(] pattern [ | pattern ] ... ) list ;; ] ... esac`

case 命令首先扩展 word，然后依次试着用每个 pattern 来匹配它，使用与路径扩展相同的匹配规则（参见下面的[路径扩展](#路径扩展)章节）。如果找到一个匹配，相应的序列将被执行。找到一个匹配之后，不会再尝试其后的匹配。如果没有模式可以匹配，返回值是 0。否则，返回序列中最后执行的命令的返回值。

`if list; then list; [ elif list; then list; ] ... [ else list; ] fi`

序列 if list 被执行。如果退出状态是 0，then list 将被执行。否则，每个 elif 将被一次执行，如果退出状态是 0，相应的 then list 将被执行，命令结束。否则，else list 将被执行，如果存在的话。退出状态是最后执行的命令的退出状态，或者是 0，如果所有条件都不满足。

`while list; do list; done`
`until list; do list; done`

while 命令不断地执行序列 do list，直到序列中最后一个命令返回 0。until 命令和 while 命令等价，除了对条件的测试恰好相反；序列 do list 执行直到序列中最后一个命令返回非零状态值。while 和 until 命令的退出状态是序列 do list 中最后一个命令的退出状态，或者是 0，如果没有执行任何命令。

`[ function ] name () { list; }`

这样可以定义一个名为 name 的函数。函数体 body 是包含在 { 和 } 之间的命令序列 list。在指定将 name 作为一个命令运行的场合，这个序列将被执行。函数的退出状态是函数体最后执行的命令的退出状态。

**注释：**

- 如果有编程基础，复合命令没什么难度，主要就是分支和循环两种流程控制
- 

## 注释

`#` 开头行都被忽略，通常用在非交互模式。交互模式下，使用内建命令 shopt 启用了 interactive_comments 选项，`#` 也起注释作用。

**注释：**

- 经常用在非交互模式，在 Shell 编程中，用来对脚本程序编写代码注释，帮助他人理解脚本程序
- 交互模式下 interactive_comments 选项默认是启用的，所以交互模式也可以使用注释
- 不通读 bash 手册的人，很少有人知道这个控制台小技巧，zsh 的交互模式也是启用的
- 这个 bash 黑科技的关键是注释内容会放到历史命令里
- 在控制台执行下面的操作，体会一下
- `#ls`, `history` 会看到 `#ls` 命令, `ctrl+r ls` 会调出历史命令
- 下面是这个技巧的使用场景
- 假设我们要执行某个命令 c1，命令敲了一半，发现需要先执行另一个命令 c2，c1 回头再执行
- 如果不知道这个技巧，我们会敲快捷键 ctrl + u，把控制台当前的 c1 命令删除，再输入 c2 命令
- c2 完成后，再把 c1 命令重新敲一遍，完成最终的操作
- 知道这个技巧后，不需要 ctrl + u 删除 c1 命令，而是在 c1 命令行首添加 `#` 字符，敲回车
- 这个时候注释的 c1 命令会到放到命令历史中，直接敲 c2 命令，c2 执行完后
- 从命令历史中调出来注释掉的 c1 命令，去掉最前面的注释符号，来运行 c1 命令
- 因为是从命令历史中调出的 c1 命令，避免了从头输入 c1 命令，提高了工作效率

## 引用

## 参数（parameters）

### 位置参数

### 特殊参数

### Shell 内置变量

### 数组

## 扩展

### 花括号扩展

### Tilde 扩展

### 参数扩展

### 命令替换

### 算术扩展

### 进程替换

### 单词分割

### 路径扩展

### 引用移除

## 重定向

### 重定向输入


### 重定向输出

### 重定向输出的追加模式

## 别名

## 函数

## 算术求值

## 条件表达式

## 简单命令扩展

## 命令执行

## 命令执行环境

## 环境

## 退出状态

## 信号

## 作业控制


## 提示符

## readline 库

## 可编程补全


## 历史

## 历史扩展


## 内置命令

## 受限的 shell

## 扩展阅读

- `man zsh`

